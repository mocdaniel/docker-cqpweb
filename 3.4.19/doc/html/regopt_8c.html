<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CWB: cl/regopt.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CWB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_0b9712b4d566c131b10613af70a8e558.html">cl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">regopt.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The CL_Regex object, and the CL Regular Expression Optimiser.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;glib.h&gt;</code><br />
<code>#include &quot;<a class="el" href="globals_8h.html">globals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="regopt_8h.html">regopt.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:adb2a713b53698607ab6816aa6a7c6c21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#adb2a713b53698607ab6816aa6a7c6c21">PCRE_STUDY_JIT_COMPILE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:adb2a713b53698607ab6816aa6a7c6c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab312a681f0a8c861a08f9d26a3f4ab95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse</a> (char *regex)</td></tr>
<tr class="memdesc:ab312a681f0a8c861a08f9d26a3f4ab95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyses a regular expression and tries to find the best set of grains.  <a href="#ab312a681f0a8c861a08f9d26a3f4ab95">More...</a><br /></td></tr>
<tr class="separator:ab312a681f0a8c861a08f9d26a3f4ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4607eb8e094b7699062df8eb744058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex</a> (char *regex, int flags, <a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a> <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>)</td></tr>
<tr class="memdesc:a2c4607eb8e094b7699062df8eb744058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new CL_regex object (ie a regular expression buffer).  <a href="#a2c4607eb8e094b7699062df8eb744058">More...</a><br /></td></tr>
<tr class="separator:a2c4607eb8e094b7699062df8eb744058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268fbea810e17003de65334cbceafbca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a268fbea810e17003de65334cbceafbca">cl_regex_optimised</a> (<a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a> rx)</td></tr>
<tr class="memdesc:a268fbea810e17003de65334cbceafbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the level of optimisation of a CL_Regex.  <a href="#a268fbea810e17003de65334cbceafbca">More...</a><br /></td></tr>
<tr class="separator:a268fbea810e17003de65334cbceafbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ac1df18a7c59850bb5e798237b50a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ade6ac1df18a7c59850bb5e798237b50a">cl_regex_match</a> (<a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a> rx, char *str, int normalize_utf8)</td></tr>
<tr class="memdesc:ade6ac1df18a7c59850bb5e798237b50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a regular expression against a string.  <a href="#ade6ac1df18a7c59850bb5e798237b50a">More...</a><br /></td></tr>
<tr class="separator:ade6ac1df18a7c59850bb5e798237b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18bf7e3faf1265c2d987ecc6ba6ab0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ab18bf7e3faf1265c2d987ecc6ba6ab0f">cl_delete_regex</a> (<a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a> rx)</td></tr>
<tr class="memdesc:ab18bf7e3faf1265c2d987ecc6ba6ab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a CL_Regex object, and frees all resources associated with the pre-compiled regex.  <a href="#ab18bf7e3faf1265c2d987ecc6ba6ab0f">More...</a><br /></td></tr>
<tr class="separator:ab18bf7e3faf1265c2d987ecc6ba6ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f79b3c3dcb006c8f3414cd6465ba7ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a9f79b3c3dcb006c8f3414cd6465ba7ec">is_safe_char</a> (unsigned char c)</td></tr>
<tr class="memdesc:a9f79b3c3dcb006c8f3414cd6465ba7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given character a 'safe' character which will only match itself in a regex?  <a href="#a9f79b3c3dcb006c8f3414cd6465ba7ec">More...</a><br /></td></tr>
<tr class="separator:a9f79b3c3dcb006c8f3414cd6465ba7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edd83f45f61798f29b5c1e1b8f956bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a8edd83f45f61798f29b5c1e1b8f956bc">is_ascii_alnum</a> (unsigned char c)</td></tr>
<tr class="memdesc:a8edd83f45f61798f29b5c1e1b8f956bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given character an ASCII alphanumeric?  <a href="#a8edd83f45f61798f29b5c1e1b8f956bc">More...</a><br /></td></tr>
<tr class="separator:a8edd83f45f61798f29b5c1e1b8f956bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51355c2edaeac17170728e2a36515a99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a51355c2edaeac17170728e2a36515a99">is_ascii_punct</a> (unsigned char c)</td></tr>
<tr class="memdesc:a51355c2edaeac17170728e2a36515a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given character ASCII punctuation?  <a href="#a51355c2edaeac17170728e2a36515a99">More...</a><br /></td></tr>
<tr class="separator:a51355c2edaeac17170728e2a36515a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153c50a88aa7b5a1b274eb31b47a2f83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a153c50a88aa7b5a1b274eb31b47a2f83">is_hexadecimal</a> (unsigned char c)</td></tr>
<tr class="memdesc:a153c50a88aa7b5a1b274eb31b47a2f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given character a valid hexadecimal digit?  <a href="#a153c50a88aa7b5a1b274eb31b47a2f83">More...</a><br /></td></tr>
<tr class="separator:a153c50a88aa7b5a1b274eb31b47a2f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f13952d3ec437f9026f619d5b01e471"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a6f13952d3ec437f9026f619d5b01e471">read_escape_seq</a> (char *mark)</td></tr>
<tr class="memdesc:a6f13952d3ec437f9026f619d5b01e471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in an escape sequence for a character or class - part of the CL Regex Optimiser.  <a href="#a6f13952d3ec437f9026f619d5b01e471">More...</a><br /></td></tr>
<tr class="separator:a6f13952d3ec437f9026f619d5b01e471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71807850073d353fd312b4dd8a0eb7b8"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a71807850073d353fd312b4dd8a0eb7b8">read_matchall</a> (char *mark)</td></tr>
<tr class="memdesc:a71807850073d353fd312b4dd8a0eb7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in an element matching some character - part of the CL Regex Optimiser.  <a href="#a71807850073d353fd312b4dd8a0eb7b8">More...</a><br /></td></tr>
<tr class="separator:a71807850073d353fd312b4dd8a0eb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df1b305a39abd5ce65350a82a00668"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a87df1b305a39abd5ce65350a82a00668">read_kleene</a> (char *mark, int *one_or_more)</td></tr>
<tr class="memdesc:a87df1b305a39abd5ce65350a82a00668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in a repetition operator - part of the CL Regex Optimiser.  <a href="#a87df1b305a39abd5ce65350a82a00668">More...</a><br /></td></tr>
<tr class="separator:a87df1b305a39abd5ce65350a82a00668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237d16bb69251631763e7e7853c5a662"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a237d16bb69251631763e7e7853c5a662">read_wildcard</a> (char *mark)</td></tr>
<tr class="memdesc:a237d16bb69251631763e7e7853c5a662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in a wildcard - part of the CL Regex Optimiser.  <a href="#a237d16bb69251631763e7e7853c5a662">More...</a><br /></td></tr>
<tr class="separator:a237d16bb69251631763e7e7853c5a662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a67a8d9123368ccd2b44bf6a3fa0f1a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a6a67a8d9123368ccd2b44bf6a3fa0f1a">read_grain</a> (char *mark, char *grain, int *len)</td></tr>
<tr class="memdesc:a6a67a8d9123368ccd2b44bf6a3fa0f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in a literal grain from a regex - part of the CL Regex Optimiser.  <a href="#a6a67a8d9123368ccd2b44bf6a3fa0f1a">More...</a><br /></td></tr>
<tr class="separator:a6a67a8d9123368ccd2b44bf6a3fa0f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f8befdb6db56e9d197e57131df7743"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction</a> (char *mark, int *align_start, int *align_end, int no_paren)</td></tr>
<tr class="memdesc:ae7f8befdb6db56e9d197e57131df7743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds grains in a simple disjunction group - part of the CL Regex Optimiser.  <a href="#ae7f8befdb6db56e9d197e57131df7743">More...</a><br /></td></tr>
<tr class="separator:ae7f8befdb6db56e9d197e57131df7743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70f0febe7ba408c9ea0d7523f837212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer</a> (int at_start, int at_end)</td></tr>
<tr class="memdesc:af70f0febe7ba408c9ea0d7523f837212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the public grain buffer &ndash; part of the CL Regex Optimiser.  <a href="#af70f0febe7ba408c9ea0d7523f837212">More...</a><br /></td></tr>
<tr class="separator:af70f0febe7ba408c9ea0d7523f837212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad88d21f908e7e9eff392739d19ef94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#aaad88d21f908e7e9eff392739d19ef94">make_jump_table</a> (<a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a> rx)</td></tr>
<tr class="memdesc:aaad88d21f908e7e9eff392739d19ef94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a jump table for Boyer-Moore searches &ndash; part of the CL Regex Optimiser.  <a href="#aaad88d21f908e7e9eff392739d19ef94">More...</a><br /></td></tr>
<tr class="separator:aaad88d21f908e7e9eff392739d19ef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697918b2f55aa6a0fd29906a934f5836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object</a> (<a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a> rx)</td></tr>
<tr class="memdesc:a697918b2f55aa6a0fd29906a934f5836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy grain set from internal global variables to CL_Regex object &ndash; part of the CL Regex Optimiser.  <a href="#a697918b2f55aa6a0fd29906a934f5836">More...</a><br /></td></tr>
<tr class="separator:a697918b2f55aa6a0fd29906a934f5836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4fbd44e2df4d0c89bc3d4633833dd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a5e4fbd44e2df4d0c89bc3d4633833dd1">cl_regopt_count_reset</a> (void)</td></tr>
<tr class="memdesc:a5e4fbd44e2df4d0c89bc3d4633833dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the "success counter" for optimised regexes.  <a href="#a5e4fbd44e2df4d0c89bc3d4633833dd1">More...</a><br /></td></tr>
<tr class="separator:a5e4fbd44e2df4d0c89bc3d4633833dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac579f14edd519c3f2aa4a4cb33c76fcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ac579f14edd519c3f2aa4a4cb33c76fcb">cl_regopt_count_get</a> (void)</td></tr>
<tr class="memdesc:ac579f14edd519c3f2aa4a4cb33c76fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reading from the "success counter" for optimised regexes.  <a href="#ac579f14edd519c3f2aa4a4cb33c76fcb">More...</a><br /></td></tr>
<tr class="separator:ac579f14edd519c3f2aa4a4cb33c76fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a17c41125f23920984f3734380cab57c4"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a17c41125f23920984f3734380cab57c4">cl_regopt_grain</a> [<a class="el" href="regopt_8h.html#aafa5fbfbe826a5bf208d173bf0609747">MAX_GRAINS</a>]</td></tr>
<tr class="memdesc:a17c41125f23920984f3734380cab57c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of 'grains' (any matching string must contain one of these)  <a href="#a17c41125f23920984f3734380cab57c4">More...</a><br /></td></tr>
<tr class="separator:a17c41125f23920984f3734380cab57c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b125ab93c3082f07ff0d7635350079"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a65b125ab93c3082f07ff0d7635350079">cl_regopt_grain_len</a></td></tr>
<tr class="memdesc:a65b125ab93c3082f07ff0d7635350079"><td class="mdescLeft">&#160;</td><td class="mdescRight">length of shortest grain (in characters)  <a href="#a65b125ab93c3082f07ff0d7635350079">More...</a><br /></td></tr>
<tr class="separator:a65b125ab93c3082f07ff0d7635350079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4527918221c359efeb1d01fb10a1a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ac4527918221c359efeb1d01fb10a1a93">cl_regopt_grains</a></td></tr>
<tr class="memdesc:ac4527918221c359efeb1d01fb10a1a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of grains  <a href="#ac4527918221c359efeb1d01fb10a1a93">More...</a><br /></td></tr>
<tr class="separator:ac4527918221c359efeb1d01fb10a1a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d3ff55dc4223346a2c4f9c4f4cd30f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a44d3ff55dc4223346a2c4f9c4f4cd30f">cl_regopt_anchor_start</a></td></tr>
<tr class="memdesc:a44d3ff55dc4223346a2c4f9c4f4cd30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean: whether grains are anchored at beginning of string.  <a href="#a44d3ff55dc4223346a2c4f9c4f4cd30f">More...</a><br /></td></tr>
<tr class="separator:a44d3ff55dc4223346a2c4f9c4f4cd30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea8fcadfd245bf518d90e45c825d518"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#aeea8fcadfd245bf518d90e45c825d518">cl_regopt_anchor_end</a></td></tr>
<tr class="memdesc:aeea8fcadfd245bf518d90e45c825d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean: whether grains are anchored at end of string.  <a href="#aeea8fcadfd245bf518d90e45c825d518">More...</a><br /></td></tr>
<tr class="separator:aeea8fcadfd245bf518d90e45c825d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045df50c2f24d752eaf8aaa4e5dfe2b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a045df50c2f24d752eaf8aaa4e5dfe2b9">cl_regopt_utf8</a></td></tr>
<tr class="memdesc:a045df50c2f24d752eaf8aaa4e5dfe2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the regular expression is in UTF-8 encoding (set before calling <a class="el" href="regopt_8c.html#ab312a681f0a8c861a08f9d26a3f4ab95" title="Analyses a regular expression and tries to find the best set of grains. ">cl_regopt_analyse()</a>)  <a href="#a045df50c2f24d752eaf8aaa4e5dfe2b9">More...</a><br /></td></tr>
<tr class="separator:a045df50c2f24d752eaf8aaa4e5dfe2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d9d4be4e6b1ead777698efd2b39098"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ae4d9d4be4e6b1ead777698efd2b39098">grain_buffer</a> [<a class="el" href="regopt_8h.html#aafa5fbfbe826a5bf208d173bf0609747">MAX_GRAINS</a>]</td></tr>
<tr class="memdesc:ae4d9d4be4e6b1ead777698efd2b39098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate buffer for grains.  <a href="#ae4d9d4be4e6b1ead777698efd2b39098">More...</a><br /></td></tr>
<tr class="separator:ae4d9d4be4e6b1ead777698efd2b39098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ea7a07e65b954f5245d85ebc04cbbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#ae2ea7a07e65b954f5245d85ebc04cbbf">grain_buffer_len</a> [<a class="el" href="regopt_8h.html#aafa5fbfbe826a5bf208d173bf0609747">MAX_GRAINS</a>]</td></tr>
<tr class="memdesc:ae2ea7a07e65b954f5245d85ebc04cbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">the length of each grain (in characters)  <a href="#ae2ea7a07e65b954f5245d85ebc04cbbf">More...</a><br /></td></tr>
<tr class="separator:ae2ea7a07e65b954f5245d85ebc04cbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6572b918e13646e4ca08c5ce0e40ce8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a6572b918e13646e4ca08c5ce0e40ce8a">grain_buffer_grains</a> = 0</td></tr>
<tr class="memdesc:a6572b918e13646e4ca08c5ce0e40ce8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of grains currently in the intermediate buffer.  <a href="#a6572b918e13646e4ca08c5ce0e40ce8a">More...</a><br /></td></tr>
<tr class="separator:a6572b918e13646e4ca08c5ce0e40ce8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e2cfc536f9bb84b772f3cacec75635"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a81e2cfc536f9bb84b772f3cacec75635">public_grain_data</a> [<a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>]</td></tr>
<tr class="memdesc:a81e2cfc536f9bb84b772f3cacec75635"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer for grain strings.  <a href="#a81e2cfc536f9bb84b772f3cacec75635">More...</a><br /></td></tr>
<tr class="separator:a81e2cfc536f9bb84b772f3cacec75635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be657173ddc2221aa23f1eac93286c2"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a3be657173ddc2221aa23f1eac93286c2">local_grain_data</a> [<a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>]</td></tr>
<tr class="memdesc:a3be657173ddc2221aa23f1eac93286c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer for grain strings.  <a href="#a3be657173ddc2221aa23f1eac93286c2">More...</a><br /></td></tr>
<tr class="separator:a3be657173ddc2221aa23f1eac93286c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1fce7eeb5bcc7601316ca301810a90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a2a1fce7eeb5bcc7601316ca301810a90">cl_regopt_successes</a> = 0</td></tr>
<tr class="memdesc:a2a1fce7eeb5bcc7601316ca301810a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter of how many times the "grain" system has allwoed us to avoid calling the regex engine.  <a href="#a2a1fce7eeb5bcc7601316ca301810a90">More...</a><br /></td></tr>
<tr class="separator:a2a1fce7eeb5bcc7601316ca301810a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e088023b2127e96b872cdb4b1c6424"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="regopt_8c.html#a72e088023b2127e96b872cdb4b1c6424">cl_regex_error</a> [<a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>]</td></tr>
<tr class="memdesc:a72e088023b2127e96b872cdb4b1c6424"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error message from (PCRE) regex compilation are placed in this buffer if <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058" title="Create a new CL_regex object (ie a regular expression buffer). ">cl_new_regex()</a> fails.  <a href="#a72e088023b2127e96b872cdb4b1c6424">More...</a><br /></td></tr>
<tr class="separator:a72e088023b2127e96b872cdb4b1c6424"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The CL_Regex object, and the CL Regular Expression Optimiser. </p>
<p>This is the CL front-end to POSIX regular expressions with CL semantics (most notably: CL regexes always match the entire string and NOT substrings.)</p>
<p>Note that the optimiser is handled automatically by the CL_Regex object.</p>
<p>All variables / functions containing "regopt" are internal to this module and are not exported in the CL API.</p>
<p>Optimisation is done by means of "grains". The grain array in a CL_Regex object is a list of short strings. Any string which will match the regex must contain at least one of these. Thus, the grains provide a quick way of filtering out strings that definitely WON'T match, and avoiding a time-wasting call to the POSIX regex matching function.</p>
<p>While a regex is being optimised, the grains are stored in non-exported global variables in this module. Subsequently they are transferred to members of the CL_regex object with which they are associated. The use of global variables and a fixed-size buffer for grains is partly due to historical reasons, but it does also serve to reduce memory allocation overhead. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="adb2a713b53698607ab6816aa6a7c6c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCRE_STUDY_JIT_COMPILE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab18bf7e3faf1265c2d987ecc6ba6ab0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_delete_regex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a>&#160;</td>
          <td class="paramname"><em>rx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a CL_Regex object, and frees all resources associated with the pre-compiled regex. </p>
<p>Note that we use cl_free to deallocate the internal PCRE buffers, not pcre_free, for the simple reason that pcre_free is just a function pointer that will normally contain free, and thus we miss out on the checking that cl_free provides.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>The CL_Regex to delete. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="struct___c_l___regex.html#a0a0140b9b50c4e2d2d935f0211bcae5e">_CL_Regex::extra</a>, <a class="el" href="struct___c_l___regex.html#a343da7a5241d5dd4042b632f9c39006e">_CL_Regex::grain</a>, <a class="el" href="struct___c_l___regex.html#a809c37615b266e2fdd396ac191b9a93c">_CL_Regex::grains</a>, <a class="el" href="struct___c_l___regex.html#a6e12607ff9600c7fbf261725f217ec10">_CL_Regex::haystack_buf</a>, <a class="el" href="struct___c_l___regex.html#ad1e74d51f9c3f4a39dcee30f069f4987">_CL_Regex::haystack_casefold</a>, and <a class="el" href="struct___c_l___regex.html#a133399bb3ea4f4e15df4fc72188db775">_CL_Regex::needle</a>.</p>

<p>Referenced by <a class="el" href="cl_8h.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea">cl_regex2id()</a>, <a class="el" href="tree_8h.html#a5e46fd61455c86e9a9011fd5cb094fd3">free_booltree()</a>, <a class="el" href="eval_8h.html#af29e9f19b26beddcdba87657cc915704">free_environment()</a>, and <a class="el" href="cwb-scan-corpus_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c4607eb8e094b7699062df8eb744058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a> cl_new_regex </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cl_8h.html#a3502421ae8eac74673133702852dde32">CorpusCharset</a>&#160;</td>
          <td class="paramname"><em>charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new CL_regex object (ie a regular expression buffer). </p>
<p>This function compiles the regular expression according to the specified flags (IGNORE_CASE and/or IGNORE_DIAC and/or REQUIRE_NFC) and for the specified character encoding. The regex is automatically anchored to the start and end of the string (i.e. wrapped in ^(?:...)$).</p>
<p>The regular expression engine used is PCRE. However, the regex is optimized by scanning it for literal strings ("grains") that must be contained in any match; the grains can be used as a fast pre-filter (using Boyer-Moore search for the grains).</p>
<p>The optimizer only understands a subset of PCRE syntax:</p><ul>
<li>literal characters (alphanumeric, safe punctuation, escaped punctuation)</li>
<li>numeric character codes ( and )</li>
<li>escape sequences for character classes and Unicode properties</li>
<li>all repetition operators</li>
<li>simple alternatives (...|...|...)</li>
<li>nested capturing (...) and non-capturing (?:...) groups Any regexp that contains other syntactic elements such as</li>
<li>character sets [...]</li>
<li>named groups, look-ahead and look-behind patterns, etc.</li>
<li>backreferences</li>
<li>modifiers such as (?i) cannot be parsed and optimized. Note that even if a regexp is parsed by the optimizer, it might not be able to extract all grains (because grain recognition uses an even more restrictive syntax).</li>
</ul>
<p>The optimizer is always disabled with IGNORE_DIAC if either PCRE JIT is available or the charset is UTF-8. Testing has showed that in these cases the overhead from case-folding each input string outweighs the benefits of the optimizer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>String containing the regular expression </td></tr>
    <tr><td class="paramname">flags</td><td>IGNORE_CASE, or IGNORE_DIAC, or both, or 0. </td></tr>
    <tr><td class="paramname">charset</td><td>The character set of the regex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new CL_Regex object, or NULL in case of error. </dd></dl>

<p>References <a class="el" href="cl_8h.html#af731838e4fa831743c660972c8499a14">CDA_EBADREGEX</a>, <a class="el" href="cl_8h.html#a1fa2e2ab47bd2c689b68a78bdac22028">CDA_OK</a>, <a class="el" href="struct___c_l___regex.html#ab7d33183c58d7df43cc5602b9c842b37">_CL_Regex::charset</a>, <a class="el" href="cwb-check-input_8c.html#ab7d33183c58d7df43cc5602b9c842b37">charset</a>, <a class="el" href="globals_8c.html#a5c4290325b240eac5fe1542a8743286a">cl_debug</a>, <a class="el" href="cdaccess_8c.html#af97f2ad4a69c7d0105f9cee4a51b29b8">cl_errno</a>, <a class="el" href="cl_8h.html#a9e15a3c725711d9effd623b2f3e225be">cl_free</a>, <a class="el" href="cl_8h.html#a4e4eccd789155123ab533ed0cecbecea">cl_malloc()</a>, <a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>, <a class="el" href="regopt_8c.html#a72e088023b2127e96b872cdb4b1c6424">cl_regex_error</a>, <a class="el" href="regopt_8c.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8c.html#a17c41125f23920984f3734380cab57c4">cl_regopt_grain</a>, <a class="el" href="regopt_8c.html#ac4527918221c359efeb1d01fb10a1a93">cl_regopt_grains</a>, <a class="el" href="regopt_8c.html#a045df50c2f24d752eaf8aaa4e5dfe2b9">cl_regopt_utf8</a>, <a class="el" href="cl_8h.html#a708281d7f482a1999c70df6c353d66e1">cl_string_canonical()</a>, <a class="el" href="cl_8h.html#a8e3a6183c822cb47f163cc14d114f0d5">cl_string_latex2iso()</a>, <a class="el" href="struct___c_l___regex.html#a0a0140b9b50c4e2d2d935f0211bcae5e">_CL_Regex::extra</a>, <a class="el" href="struct___c_l___regex.html#a809c37615b266e2fdd396ac191b9a93c">_CL_Regex::grains</a>, <a class="el" href="struct___c_l___regex.html#a6e12607ff9600c7fbf261725f217ec10">_CL_Regex::haystack_buf</a>, <a class="el" href="struct___c_l___regex.html#ad1e74d51f9c3f4a39dcee30f069f4987">_CL_Regex::haystack_casefold</a>, <a class="el" href="struct___c_l___regex.html#a2a54e4cd12e90b8adc180c6ed49d3fe9">_CL_Regex::icase</a>, <a class="el" href="struct___c_l___regex.html#a15e57c2d33cf01a99085d5872f6f5e5f">_CL_Regex::idiac</a>, <a class="el" href="cl_8h.html#a1f397c74f7f8ba3952858c70eb19d082">IGNORE_CASE</a>, <a class="el" href="cl_8h.html#a2e9f85ae8ad88191c60cf4269b9ab296">IGNORE_DIAC</a>, <a class="el" href="struct___c_l___regex.html#a133399bb3ea4f4e15df4fc72188db775">_CL_Regex::needle</a>, <a class="el" href="regopt_8c.html#adb2a713b53698607ab6816aa6a7c6c21">PCRE_STUDY_JIT_COMPILE</a>, <a class="el" href="regopt_8c.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object()</a>, <a class="el" href="cl_8h.html#aa0c07ad5df716ec7aba3dba491c5ab8d">REQUIRE_NFC</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p>Referenced by <a class="el" href="cl_8h.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea">cl_regex2id()</a>, <a class="el" href="parse__actions_8h.html#a6cc225469d64fbddecf2d9dce7e0a28d">do_flagged_string()</a>, <a class="el" href="parse__actions_8h.html#a4335ddbb14865c031041a194e182ed92">do_XMLTag()</a>, <a class="el" href="cwb-scan-corpus_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, and <a class="el" href="cwb-scan-corpus_8c.html#a8947ac051b910a311d2d1f0ef28272bd">scancorpus_add_key()</a>.</p>

</div>
</div>
<a class="anchor" id="ade6ac1df18a7c59850bb5e798237b50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regex_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a>&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normalize_utf8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a regular expression against a string. </p>
<p>The pre-compiled regular expression contained in the CL_Regex is compared to the string. This regex automatically uses the case/accent folding flags and character encoding that were specified when the CL_Regex constructor was called.</p>
<p>If the subject string is a UTF-8 string from an external sources, the caller can request enforcement of the subject to canonical NFC form by setting the third argument to true.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058" title="Create a new CL_regex object (ie a regular expression buffer). ">cl_new_regex</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>The regular expression to match. </td></tr>
    <tr><td class="paramname">str</td><td>The subject (the string to compare the regex to). </td></tr>
    <tr><td class="paramname">normalize_utf8</td><td>If a UTF-8 string from an external source is passed as the subject, set to this parameter to true, and the function will make sure that the comparison is based on the canonical NFC form. For known-NFC strings, this parameter should be false. If the regex is not UTF-8, this parameter is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean: true if the regex matched, otherwise false. </dd></dl>

<p>References <a class="el" href="struct___c_l___regex.html#a93e5ad5e0410fdbd7c65a09793a14cb6">_CL_Regex::anchor_end</a>, <a class="el" href="struct___c_l___regex.html#a4e3ccc6f2ec66b18f80763c9101dc2a7">_CL_Regex::anchor_start</a>, <a class="el" href="struct___c_l___regex.html#ab7d33183c58d7df43cc5602b9c842b37">_CL_Regex::charset</a>, <a class="el" href="globals_8c.html#a5c4290325b240eac5fe1542a8743286a">cl_debug</a>, <a class="el" href="globals_8c.html#a783947bd6a04f6ad65c3d25f95a80b9a">cl_optimize</a>, <a class="el" href="regopt_8c.html#a2a1fce7eeb5bcc7601316ca301810a90">cl_regopt_successes</a>, <a class="el" href="cl_8h.html#a708281d7f482a1999c70df6c353d66e1">cl_string_canonical()</a>, <a class="el" href="struct___c_l___regex.html#a0a0140b9b50c4e2d2d935f0211bcae5e">_CL_Regex::extra</a>, <a class="el" href="struct___c_l___regex.html#a343da7a5241d5dd4042b632f9c39006e">_CL_Regex::grain</a>, <a class="el" href="struct___c_l___regex.html#a6f097fa6018c5b24ea16507555185feb">_CL_Regex::grain_len</a>, <a class="el" href="struct___c_l___regex.html#a809c37615b266e2fdd396ac191b9a93c">_CL_Regex::grains</a>, <a class="el" href="struct___c_l___regex.html#a6e12607ff9600c7fbf261725f217ec10">_CL_Regex::haystack_buf</a>, <a class="el" href="struct___c_l___regex.html#ad1e74d51f9c3f4a39dcee30f069f4987">_CL_Regex::haystack_casefold</a>, <a class="el" href="struct___c_l___regex.html#a2a54e4cd12e90b8adc180c6ed49d3fe9">_CL_Regex::icase</a>, <a class="el" href="struct___c_l___regex.html#a15e57c2d33cf01a99085d5872f6f5e5f">_CL_Regex::idiac</a>, <a class="el" href="struct___c_l___regex.html#a9da424d392549ca48c495ad456441139">_CL_Regex::jumptable</a>, <a class="el" href="struct___c_l___regex.html#a133399bb3ea4f4e15df4fc72188db775">_CL_Regex::needle</a>, <a class="el" href="cl_8h.html#aa0c07ad5df716ec7aba3dba491c5ab8d">REQUIRE_NFC</a>, and <a class="el" href="cl_8h.html#aa018eeb7e5a4bb1586a3f4337011daeaa3946b00fe1f38206339d69285cda6b03">utf8</a>.</p>

<p>Referenced by <a class="el" href="cl_8h.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea">cl_regex2id()</a>, <a class="el" href="eval_8h.html#a1c6b9087d4b9c61e2be81a7a68e174cc">eval_bool()</a>, <a class="el" href="eval_8c.html#aaf8dd0672a1325480955ab8397b1928b">eval_constraint()</a>, <a class="el" href="cwb-scan-corpus_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>, <a class="el" href="eval_8c.html#abcf01813cbf1161269761c3d6a2dc239">matchfirstpattern()</a>, and <a class="el" href="cwb-scan-corpus_8c.html#a0fbb5401351cd552df4771870b6726c8">scancorpus_word_is_regular()</a>.</p>

</div>
</div>
<a class="anchor" id="a268fbea810e17003de65334cbceafbca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regex_optimised </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a>&#160;</td>
          <td class="paramname"><em>rx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the level of optimisation of a CL_Regex. </p>
<p>This function returns the approximate level of optimisation, computed from the ratio of grain length to number of grains (0 = no grains, ergo not optimised at all).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>The CL_Regex to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if rx is not optimised; otherwise an integer indicating optimisation level. </dd></dl>

<p>References <a class="el" href="struct___c_l___regex.html#a6f097fa6018c5b24ea16507555185feb">_CL_Regex::grain_len</a>, and <a class="el" href="struct___c_l___regex.html#a809c37615b266e2fdd396ac191b9a93c">_CL_Regex::grains</a>.</p>

<p>Referenced by <a class="el" href="cl_8h.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea">cl_regex2id()</a>.</p>

</div>
</div>
<a class="anchor" id="ab312a681f0a8c861a08f9d26a3f4ab95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_analyse </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyses a regular expression and tries to find the best set of grains. </p>
<p>Part of the regex optimiser. For a given regular expression, this function will try to extract a set of grains from regular expression {regex_string}. These grains are then used by the CL regex matcher and <a class="el" href="cdaccess_8c.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea" title="Gets a list of the ids of those items on a given Attribute that match a particular regular-expression...">cl_regex2id()</a> as a pre-filter for faster regular expression search.</p>
<p>The function only recognizes relatively simple regular expressions without recursive nesting, which roughly correspond to wildcard searches similar to SQL's LIKE operator. Searching for a fixed prefix, suffix or infix (or a small set of alternatives) will see the most noticeable performance improvement. Any more complex expression is passed directly to the standard PCRE evaluation. See <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058" title="Create a new CL_regex object (ie a regular expression buffer). ">cl_new_regex()</a> for an overview of the supported subsets of PCRE syntax.</p>
<p>If successful, this function returns True and stores the grains in the optiomiser's global variables above, from which they then must be copied to a CL_Regex object with <a class="el" href="regopt_8c.html#a697918b2f55aa6a0fd29906a934f5836" title="Copy grain set from internal global variables to CL_Regex object â€“ part of the CL Regex Optimiser...">regopt_data_copy_to_regex_object()</a>. This step will also casefold grains if necessary and prepare the Boyer-Moore jump tables.</p>
<p>Usage: optimised = cl_regopt_analyse(regex_string);</p>
<p>This is a non-exported function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>String containing the regex to optimise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean: true = ok, false = couldn't optimise regex. </dd></dl>
<p>The code below parses a regular expression using the supported PCRE subset and attempts to extract a literal string ("grain") that must occur in every match of the regular expression. In a disjunction group, each alternative must contain a grain in order to be used for optimized matching; we refer to this as a complete grain set.</p>
<p>The algorithm scans the regular expression from left to right, looking for the following supported elements in the specified order:</p>
<ol type="1">
<li>a literal grain (read_grain)</li>
<li>a parenthesized disjunction containing grains (read_disjunction)</li>
<li>a segment matching some, possibly empty substring (read_wildcard), including recursively nested capturing or non-capturing groups</li>
</ol>
<p>See the respective functions for further information on these elements. Grains are collected by read_grain and read_disjunction in a local buffer. If a complete grain set has been found, it replaces the previous global grain set if it is considered to be more effective based on the length and number of grains.</p>
<p>As a special case, the optimizer first attempts to match the entire regexp as a simple disjunction (read_disjunction) without parentheses.</p>

<p>References <a class="el" href="globals_8c.html#a5c4290325b240eac5fe1542a8743286a">cl_debug</a>, <a class="el" href="regopt_8c.html#aeea8fcadfd245bf518d90e45c825d518">cl_regopt_anchor_end</a>, <a class="el" href="regopt_8c.html#a44d3ff55dc4223346a2c4f9c4f4cd30f">cl_regopt_anchor_start</a>, <a class="el" href="regopt_8c.html#a65b125ab93c3082f07ff0d7635350079">cl_regopt_grain_len</a>, <a class="el" href="regopt_8c.html#ac4527918221c359efeb1d01fb10a1a93">cl_regopt_grains</a>, <a class="el" href="regopt_8c.html#ae4d9d4be4e6b1ead777698efd2b39098">grain_buffer</a>, <a class="el" href="regopt_8c.html#a6572b918e13646e4ca08c5ce0e40ce8a">grain_buffer_grains</a>, <a class="el" href="regopt_8c.html#ae2ea7a07e65b954f5245d85ebc04cbbf">grain_buffer_len</a>, <a class="el" href="regopt_8c.html#a3be657173ddc2221aa23f1eac93286c2">local_grain_data</a>, <a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction()</a>, <a class="el" href="regopt_8c.html#a6a67a8d9123368ccd2b44bf6a3fa0f1a">read_grain()</a>, <a class="el" href="regopt_8c.html#a87df1b305a39abd5ce65350a82a00668">read_kleene()</a>, <a class="el" href="regopt_8c.html#a237d16bb69251631763e7e7853c5a662">read_wildcard()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>.</p>

</div>
</div>
<a class="anchor" id="ac579f14edd519c3f2aa4a4cb33c76fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_count_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reading from the "success counter" for optimised regexes. </p>
<p>The counter is incremented by 1 every time the "grain" system is used successfully to avoid calling PCRE. That is, it is incremented every time a string is scrutinised and found to contain none of the grains.</p>
<p>Usage:</p>
<p><a class="el" href="regopt_8c.html#a5e4fbd44e2df4d0c89bc3d4633833dd1" title="Reset the &quot;success counter&quot; for optimised regexes. ">cl_regopt_count_reset()</a>;</p>
<p>for (i = 0, hits = 0; i &lt; n; i++) if (cl_regex_match(rx, haystacks[i])) hits++;</p>
<p>fprintf(stderr, "Found %d matches; avoided regex matching %d times out of %d trials", hits, <a class="el" href="regopt_8c.html#ac579f14edd519c3f2aa4a4cb33c76fcb" title="Get a reading from the &quot;success counter&quot; for optimised regexes. ">cl_regopt_count_get()</a>, n );</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="regopt_8c.html#a5e4fbd44e2df4d0c89bc3d4633833dd1" title="Reset the &quot;success counter&quot; for optimised regexes. ">cl_regopt_count_reset</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an integer indicating the number of times a regular expression has been matched using the regopt system of "grains", rather than by calling an external regex library. </dd></dl>

<p>References <a class="el" href="regopt_8c.html#a2a1fce7eeb5bcc7601316ca301810a90">cl_regopt_successes</a>.</p>

<p>Referenced by <a class="el" href="cl_8h.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea">cl_regex2id()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e4fbd44e2df4d0c89bc3d4633833dd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl_regopt_count_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the "success counter" for optimised regexes. </p>

<p>References <a class="el" href="regopt_8c.html#a2a1fce7eeb5bcc7601316ca301810a90">cl_regopt_successes</a>.</p>

<p>Referenced by <a class="el" href="cl_8h.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea">cl_regex2id()</a>.</p>

</div>
</div>
<a class="anchor" id="a8edd83f45f61798f29b5c1e1b8f956bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_ascii_alnum </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the given character an ASCII alphanumeric? </p>
<p>ASCII alphanumeric characters comprise A-Z, a-z and 0-9; they are the only characters that form special escape sequences in PCRE regular expressions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character (cast to unsigned for the comparison). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ASCII alphanumeric; false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="regopt_8c.html#a6f13952d3ec437f9026f619d5b01e471">read_escape_seq()</a>.</p>

</div>
</div>
<a class="anchor" id="a51355c2edaeac17170728e2a36515a99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_ascii_punct </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the given character ASCII punctuation? </p>
<p>ASCII punctuation symbols are the only characters that may need to be protected by a \ in regular expressions. They cannot form special escape sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character (cast to unsigned for the comparison). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if ASCII alphanumeric; false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="regopt_8c.html#a6a67a8d9123368ccd2b44bf6a3fa0f1a">read_grain()</a>.</p>

</div>
</div>
<a class="anchor" id="a153c50a88aa7b5a1b274eb31b47a2f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_hexadecimal </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the given character a valid hexadecimal digit? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character (cast to unsigned for the comparison). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if valid hexidecimal digit; false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="regopt_8c.html#a6f13952d3ec437f9026f619d5b01e471">read_escape_seq()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f79b3c3dcb006c8f3414cd6465ba7ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_safe_char </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the given character a 'safe' character which will only match itself in a regex? </p>
<p>What counts as safe: A to Z, a to z, 0 to 9, minus, quote marks, percent, ampersand, slash, excl mark, colon, semi colon, character, underscore, tilde, any values above 0x7f (ISO 8859 extension or UTF-8 non-ASCII character).</p>
<p>What counts as not safe therefore includes: brackets, braces, square brackets; questionmark, plus, and star; circumflex and dollar sign; dot; hash; backslash, etc. (But, in UTF8, Unicode PUNC area equivalents of these characters will be safe.)</p>
<p>A safe character can never be the start of a meta element (even if it might appear as part of one), so it's safe to include in a literal grain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character (cast to unsigned for the comparison). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for non-special characters; false for special characters. </dd></dl>

<p>Referenced by <a class="el" href="regopt_8c.html#a6a67a8d9123368ccd2b44bf6a3fa0f1a">read_grain()</a>, and <a class="el" href="regopt_8c.html#a71807850073d353fd312b4dd8a0eb7b8">read_matchall()</a>.</p>

</div>
</div>
<a class="anchor" id="aaad88d21f908e7e9eff392739d19ef94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_jump_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a>&#160;</td>
          <td class="paramname"><em>rx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a jump table for Boyer-Moore searches &ndash; part of the CL Regex Optimiser. </p>
<p>Unlike the textbook version, this jumptable includes the last character of each grain (so we don't have to start the string comparison loops every time).</p>
<p>A non-exported function. </p>

<p>References <a class="el" href="globals_8c.html#a5c4290325b240eac5fe1542a8743286a">cl_debug</a>, <a class="el" href="struct___c_l___regex.html#a343da7a5241d5dd4042b632f9c39006e">_CL_Regex::grain</a>, <a class="el" href="struct___c_l___regex.html#a6f097fa6018c5b24ea16507555185feb">_CL_Regex::grain_len</a>, <a class="el" href="struct___c_l___regex.html#a809c37615b266e2fdd396ac191b9a93c">_CL_Regex::grains</a>, and <a class="el" href="struct___c_l___regex.html#a9da424d392549ca48c495ad456441139">_CL_Regex::jumptable</a>.</p>

<p>Referenced by <a class="el" href="regopt_8h.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7f8befdb6db56e9d197e57131df7743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_disjunction </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>align_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>align_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_paren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds grains in a simple disjunction group - part of the CL Regex Optimiser. </p>
<p>This function parses a simple parenthesized disjunction within a regular expression and attempts to extract one grain from each alternative. Grains are written to the local grain buffer. If a complete grain set has been found, the functions returns a pointer to the first character after the disjunction. Otherwise it returns mark and the caller can try to accept the group with read_matchall.</p>
<p>For simplicity, only the first grain in each alternative is considered. This makes it easier to check start/end alignment of the grains. Note that the local grain buffer is always mangled, even if the function is unsuccessful.</p>
<p>The first argument, mark, must point to the '(' at the beginning of the disjunction group (unless no_paren is set).</p>
<p>The booleans align_start and align_end are set to true if the grains from <em>all</em> alternatives are anchored at the start or end of the disjunction group, respectively.</p>
<p>This is a non-exported function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>Pointer to the disjunction group (see also function description). </td></tr>
    <tr><td class="paramname">align_start</td><td>See function description. </td></tr>
    <tr><td class="paramname">align_end</td><td>See function description. </td></tr>
    <tr><td class="paramname">no_paren</td><td>Attempt to read a top-level disjunction without parentheses, which must extend to the end of the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to first character after the disjunction group iff the parse succeeded, the original pointer in the mark argument otherwise. </dd></dl>

<p>References <a class="el" href="cwb-itoa_8c.html#ac1ed595d526b1beccae8e324475d61ea">buf</a>, <a class="el" href="regopt_8c.html#ae4d9d4be4e6b1ead777698efd2b39098">grain_buffer</a>, <a class="el" href="regopt_8c.html#a6572b918e13646e4ca08c5ce0e40ce8a">grain_buffer_grains</a>, <a class="el" href="regopt_8c.html#ae2ea7a07e65b954f5245d85ebc04cbbf">grain_buffer_len</a>, <a class="el" href="regopt_8c.html#a3be657173ddc2221aa23f1eac93286c2">local_grain_data</a>, <a class="el" href="regopt_8h.html#aafa5fbfbe826a5bf208d173bf0609747">MAX_GRAINS</a>, <a class="el" href="regopt_8c.html#a6a67a8d9123368ccd2b44bf6a3fa0f1a">read_grain()</a>, and <a class="el" href="regopt_8c.html#a237d16bb69251631763e7e7853c5a662">read_wildcard()</a>.</p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f13952d3ec437f9026f619d5b01e471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_escape_seq </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in an escape sequence for a character or class - part of the CL Regex Optimiser. </p>
<p>This function reads one of the following escape sequences: ##, {###} ... hexadecimal character code {###} ... octal character code , , , , ,  ... generic character types <code></code> #, <code></code>{###} ... Unicode properties #, {###} ... negated Unicode properties  ... Unicode extended grapheme cluster </p>

<p>References <a class="el" href="regopt_8c.html#a8edd83f45f61798f29b5c1e1b8f956bc">is_ascii_alnum()</a>, and <a class="el" href="regopt_8c.html#a153c50a88aa7b5a1b274eb31b47a2f83">is_hexadecimal()</a>.</p>

<p>Referenced by <a class="el" href="regopt_8c.html#a71807850073d353fd312b4dd8a0eb7b8">read_matchall()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a67a8d9123368ccd2b44bf6a3fa0f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_grain </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>grain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in a literal grain from a regex - part of the CL Regex Optimiser. </p>
<p>A grain is a string of safe symbols: alphanumeric, safe punctuation and escaped punctuation; numeric character codes (, ) are not supported. The last symbol might be followed by a repetition operator. It is only included in the grain if the repetition count is at least one.</p>
<p>This function finds the longest grain it can starting at the point in the regex indicated by mark. If *grain is not NULL, the grain data are unescaped and copied to the specified buffer. Note that the buffer will be mangled even if no grain is matched; it is guaranteed to contain a NUL-terminated string, though. If *len is not null, the length of the grain (in characters) is stored there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>Pointer to location in the regex string from which to read. </td></tr>
    <tr><td class="paramname">grain</td><td>Optional pointer to a buffer into which the grain data will be copied. Guaranteed to contain a NUL-terminated string even if no grain is found. </td></tr>
    <tr><td class="paramname">len</td><td>Pointer to integer in which length of grain in characters will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first character after the grain it has read in (or the original "mark" pointer if no grain is found). </dd></dl>

<p>References <a class="el" href="regopt_8c.html#a045df50c2f24d752eaf8aaa4e5dfe2b9">cl_regopt_utf8</a>, <a class="el" href="regopt_8c.html#a51355c2edaeac17170728e2a36515a99">is_ascii_punct()</a>, <a class="el" href="regopt_8c.html#a9f79b3c3dcb006c8f3414cd6465ba7ec">is_safe_char()</a>, and <a class="el" href="regopt_8c.html#a87df1b305a39abd5ce65350a82a00668">read_kleene()</a>.</p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, and <a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a87df1b305a39abd5ce65350a82a00668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_kleene </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>one_or_more</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in a repetition operator - part of the CL Regex Optimiser. </p>
<p>This function reads in any repetition operator allowed in PCRE syntax:</p><ul>
<li>* (Kleene star), ?, +</li>
<li>{n}, {n,m}, {,m}, {n,}</li>
<li>optionally followed by a non-greedy (?) or possessive (+) modifier it returns a pointer to the first character after the repetition modifier it has found. If *one_or_more is not null, it is set to True if the quantifier operator mandates at least one repetition (i.e. it does not make the preceding element optional).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>Pointer to location in the regex string from which to read. </td></tr>
    <tr><td class="paramname">one_or_more</td><td>Optional pointer to integer, which will be set to True if repetition is not optional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first character after the star or other modifier it has read in (or the original "mark" pointer if a repetition modifier was not read). </dd></dl>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8c.html#a6a67a8d9123368ccd2b44bf6a3fa0f1a">read_grain()</a>, and <a class="el" href="regopt_8c.html#a237d16bb69251631763e7e7853c5a662">read_wildcard()</a>.</p>

</div>
</div>
<a class="anchor" id="a71807850073d353fd312b4dd8a0eb7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_matchall </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in an element matching some character - part of the CL Regex Optimiser. </p>
<p>This function reads in an element known to match some character. The following elements are currently recognized:</p><ul>
<li>a matchall (.)</li>
<li>a safe literal character or escaped ASCII punctuation</li>
<li>an escape sequence for a simple character class (, , etc.)</li>
<li>an escape sequence for a Unicode property</li>
<li>a hexadecimal () or octal () character code</li>
<li>a simple character set such as [a-z], [A-Z] and [0-9] The precise syntax of character sets is rather messy, so we will not make an attempt to recognize more complex sets.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>Pointer to location in the regex string from which to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first character after the character (class) it has read in (or the original "mark" pointer if nothing suitable was found). </dd></dl>

<p>References <a class="el" href="regopt_8c.html#a045df50c2f24d752eaf8aaa4e5dfe2b9">cl_regopt_utf8</a>, <a class="el" href="regopt_8c.html#a9f79b3c3dcb006c8f3414cd6465ba7ec">is_safe_char()</a>, and <a class="el" href="regopt_8c.html#a6f13952d3ec437f9026f619d5b01e471">read_escape_seq()</a>.</p>

<p>Referenced by <a class="el" href="regopt_8c.html#a237d16bb69251631763e7e7853c5a662">read_wildcard()</a>.</p>

</div>
</div>
<a class="anchor" id="a237d16bb69251631763e7e7853c5a662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_wildcard </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mark</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads in a wildcard - part of the CL Regex Optimiser. </p>
<p>This function reads in a wildcard segment consisting of an element matching some character (read_matchall) or a capturing or non-capturing group, followed by an optional quantifier (read_kleene). It returns a pointer to the first character after the wildcard segment.</p>
<p>Groups are parsed recursively and must consist of one or more alternatives containing only valid wildcard segments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mark</td><td>Pointer to location in the regex string from which to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first character after the wildcard segment (or the original "mark" pointer if a wildcard segment was not found). </dd></dl>

<p>References <a class="el" href="regopt_8c.html#a87df1b305a39abd5ce65350a82a00668">read_kleene()</a>, and <a class="el" href="regopt_8c.html#a71807850073d353fd312b4dd8a0eb7b8">read_matchall()</a>.</p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, and <a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction()</a>.</p>

</div>
</div>
<a class="anchor" id="a697918b2f55aa6a0fd29906a934f5836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regopt_data_copy_to_regex_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cl_8h.html#ab595272450836292a293ea13eb49ef0b">CL_Regex</a>&#160;</td>
          <td class="paramname"><em>rx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy grain set from internal global variables to CL_Regex object &ndash; part of the CL Regex Optimiser. </p>
<p>This function carries out four important tasks:</p><ul>
<li>It copies the grain set found by cl_regopt_analyse from the internal global buffer to member variables of the specified CL_Regex object.</li>
<li>It casefolds the grains if required (i.e. if rx-&gt;icase is True).</li>
<li>It cuts grains to equal byte length, preserving start/end anchoring if possible. Note that our implementation of Boyer-Moore search requires equally sized grains.</li>
<li>It calls make_jump_table to generate a lookup table for the Boyer-Moore search.</li>
</ul>
<p>This is a non-exported function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>a pointer to an initialized CL_Regex object </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="struct___c_l___regex.html#a93e5ad5e0410fdbd7c65a09793a14cb6">_CL_Regex::anchor_end</a>, <a class="el" href="struct___c_l___regex.html#a4e3ccc6f2ec66b18f80763c9101dc2a7">_CL_Regex::anchor_start</a>, <a class="el" href="struct___c_l___regex.html#ab7d33183c58d7df43cc5602b9c842b37">_CL_Regex::charset</a>, <a class="el" href="globals_8c.html#a5c4290325b240eac5fe1542a8743286a">cl_debug</a>, <a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>, <a class="el" href="regopt_8c.html#aeea8fcadfd245bf518d90e45c825d518">cl_regopt_anchor_end</a>, <a class="el" href="regopt_8c.html#a44d3ff55dc4223346a2c4f9c4f4cd30f">cl_regopt_anchor_start</a>, <a class="el" href="regopt_8c.html#a17c41125f23920984f3734380cab57c4">cl_regopt_grain</a>, <a class="el" href="regopt_8c.html#ac4527918221c359efeb1d01fb10a1a93">cl_regopt_grains</a>, <a class="el" href="cl_8h.html#a1afd81ceb72fcd8e9e8e91983a0528a8">cl_strdup()</a>, <a class="el" href="cl_8h.html#a708281d7f482a1999c70df6c353d66e1">cl_string_canonical()</a>, <a class="el" href="struct___c_l___regex.html#a343da7a5241d5dd4042b632f9c39006e">_CL_Regex::grain</a>, <a class="el" href="struct___c_l___regex.html#a6f097fa6018c5b24ea16507555185feb">_CL_Regex::grain_len</a>, <a class="el" href="struct___c_l___regex.html#a809c37615b266e2fdd396ac191b9a93c">_CL_Regex::grains</a>, <a class="el" href="struct___c_l___regex.html#a2a54e4cd12e90b8adc180c6ed49d3fe9">_CL_Regex::icase</a>, <a class="el" href="cl_8h.html#a1f397c74f7f8ba3952858c70eb19d082">IGNORE_CASE</a>, <a class="el" href="regopt_8c.html#a3be657173ddc2221aa23f1eac93286c2">local_grain_data</a>, and <a class="el" href="regopt_8c.html#aaad88d21f908e7e9eff392739d19ef94">make_jump_table()</a>.</p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>.</p>

</div>
</div>
<a class="anchor" id="af70f0febe7ba408c9ea0d7523f837212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_grain_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>at_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the public grain buffer &ndash; part of the CL Regex Optimiser. </p>
<p>This function copies the local grains to the public buffer, if they are better than the set of grains currently there. The decision is made with a heuristic based on the character length of the shortest grain and the number of different grains.</p>
<p>A non-exported function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">at_start</td><td>Boolean: if True, all grains are anchored on the left </td></tr>
    <tr><td class="paramname">at_end</td><td>Boolean: if True, all grains are anchored on the right </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="cwb-itoa_8c.html#ac1ed595d526b1beccae8e324475d61ea">buf</a>, <a class="el" href="regopt_8c.html#aeea8fcadfd245bf518d90e45c825d518">cl_regopt_anchor_end</a>, <a class="el" href="regopt_8c.html#a44d3ff55dc4223346a2c4f9c4f4cd30f">cl_regopt_anchor_start</a>, <a class="el" href="regopt_8c.html#a17c41125f23920984f3734380cab57c4">cl_regopt_grain</a>, <a class="el" href="regopt_8c.html#a65b125ab93c3082f07ff0d7635350079">cl_regopt_grain_len</a>, <a class="el" href="regopt_8c.html#ac4527918221c359efeb1d01fb10a1a93">cl_regopt_grains</a>, <a class="el" href="regopt_8c.html#ae4d9d4be4e6b1ead777698efd2b39098">grain_buffer</a>, <a class="el" href="regopt_8c.html#a6572b918e13646e4ca08c5ce0e40ce8a">grain_buffer_grains</a>, <a class="el" href="regopt_8c.html#ae2ea7a07e65b954f5245d85ebc04cbbf">grain_buffer_len</a>, and <a class="el" href="regopt_8c.html#a81e2cfc536f9bb84b772f3cacec75635">public_grain_data</a>.</p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a72e088023b2127e96b872cdb4b1c6424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char cl_regex_error[<a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error message from (PCRE) regex compilation are placed in this buffer if <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058" title="Create a new CL_regex object (ie a regular expression buffer). ">cl_new_regex()</a> fails. </p>
<p>This global variable is part of the CL_Regex object's API. </p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, and <a class="el" href="cl_8h.html#a6eb4641e0a1e14b63f2d5f2f5b6a8cea">cl_regex2id()</a>.</p>

</div>
</div>
<a class="anchor" id="aeea8fcadfd245bf518d90e45c825d518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_anchor_end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean: whether grains are anchored at end of string. </p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8h.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a44d3ff55dc4223346a2c4f9c4f4cd30f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_anchor_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean: whether grains are anchored at beginning of string. </p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8h.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a17c41125f23920984f3734380cab57c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* cl_regopt_grain[<a class="el" href="regopt_8h.html#aafa5fbfbe826a5bf208d173bf0609747">MAX_GRAINS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>list of 'grains' (any matching string must contain one of these) </p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, <a class="el" href="regopt_8h.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a65b125ab93c3082f07ff0d7635350079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_grain_len</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>length of shortest grain (in characters) </p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4527918221c359efeb1d01fb10a1a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_grains</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of grains </p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8h.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a1fce7eeb5bcc7601316ca301810a90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_successes = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A counter of how many times the "grain" system has allwoed us to avoid calling the regex engine. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="regopt_8c.html#ac579f14edd519c3f2aa4a4cb33c76fcb" title="Get a reading from the &quot;success counter&quot; for optimised regexes. ">cl_regopt_count_get</a> </dd></dl>

<p>Referenced by <a class="el" href="regopt_8c.html#ade6ac1df18a7c59850bb5e798237b50a">cl_regex_match()</a>, <a class="el" href="regopt_8c.html#ac579f14edd519c3f2aa4a4cb33c76fcb">cl_regopt_count_get()</a>, and <a class="el" href="regopt_8c.html#a5e4fbd44e2df4d0c89bc3d4633833dd1">cl_regopt_count_reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a045df50c2f24d752eaf8aaa4e5dfe2b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cl_regopt_utf8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>whether the regular expression is in UTF-8 encoding (set before calling <a class="el" href="regopt_8c.html#ab312a681f0a8c861a08f9d26a3f4ab95" title="Analyses a regular expression and tries to find the best set of grains. ">cl_regopt_analyse()</a>) </p>

<p>Referenced by <a class="el" href="regopt_8c.html#a2c4607eb8e094b7699062df8eb744058">cl_new_regex()</a>, <a class="el" href="regopt_8c.html#a6a67a8d9123368ccd2b44bf6a3fa0f1a">read_grain()</a>, and <a class="el" href="regopt_8c.html#a71807850073d353fd312b4dd8a0eb7b8">read_matchall()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4d9d4be4e6b1ead777698efd2b39098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* grain_buffer[<a class="el" href="regopt_8h.html#aafa5fbfbe826a5bf208d173bf0609747">MAX_GRAINS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intermediate buffer for grains. </p>
<p>When a regex is parsed, grains for each segment are written to this intermediate buffer; if the new set of grains is better than the current one, it is copied to the cl_regopt_ variables.grains in the local buffer may have different lengths </p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a6572b918e13646e4ca08c5ce0e40ce8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int grain_buffer_grains = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of grains currently in the intermediate buffer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="regopt_8c.html#ae4d9d4be4e6b1ead777698efd2b39098" title="Intermediate buffer for grains. ">grain_buffer</a> </dd></dl>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2ea7a07e65b954f5245d85ebc04cbbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int grain_buffer_len[<a class="el" href="regopt_8h.html#aafa5fbfbe826a5bf208d173bf0609747">MAX_GRAINS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the length of each grain (in characters) </p>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction()</a>, and <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="a3be657173ddc2221aa23f1eac93286c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char local_grain_data[<a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A buffer for grain strings. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="regopt_8c.html#a81e2cfc536f9bb84b772f3cacec75635" title="A buffer for grain strings. ">public_grain_data</a> </dd></dl>

<p>Referenced by <a class="el" href="regopt_8h.html#ab312a681f0a8c861a08f9d26a3f4ab95">cl_regopt_analyse()</a>, <a class="el" href="regopt_8c.html#ae7f8befdb6db56e9d197e57131df7743">read_disjunction()</a>, and <a class="el" href="regopt_8h.html#a697918b2f55aa6a0fd29906a934f5836">regopt_data_copy_to_regex_object()</a>.</p>

</div>
</div>
<a class="anchor" id="a81e2cfc536f9bb84b772f3cacec75635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char public_grain_data[<a class="el" href="cl_8h.html#ad68dfe0ca2fbad5052e8213a06f5b4ba">CL_MAX_LINE_LENGTH</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A buffer for grain strings. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="regopt_8c.html#a3be657173ddc2221aa23f1eac93286c2" title="A buffer for grain strings. ">local_grain_data</a> </dd></dl>

<p>Referenced by <a class="el" href="regopt_8c.html#af70f0febe7ba408c9ea0d7523f837212">update_grain_buffer()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 17 2017 20:15:18 for CWB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
