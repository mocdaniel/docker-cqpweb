.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CWB 3"
.TH CWB 3 "2022-05-07" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CWB \- Perl toolbox for the IMS Corpus Workbench
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use CWB;
\&
\&  # full pathnames of CQP and the CWB tools
\&  $CWB::CQP;             # cqp
\&  $CWB::Config;          # cwb\-config
\&  $CWB::Encode;          # cwb\-encode
\&  $CWB::Makeall;         # cwb\-makeall
\&  $CWB::Decode;          # cwb\-decode
\&  $CWB::Lexdecode;       # cwb\-lexdecode
\&  $CWB::DescribeCorpus;  # cwb\-describe\-corpus
\&  $CWB::Huffcode;        # cwb\-huffcode
\&  $CWB::CompressRdx;     # cwb\-compress\-rdx
\&  $CWB::Itoa;            # cwb\-itoa
\&  $CWB::Atoi;            # cwb\-atoi
\&  $CWB::SEncode;         # cwb\-s\-encode
\&  $CWB::SDecode;         # cwb\-s\-decode
\&  $CWB::ScanCorpus;      # cwb\-scan\-corpus
\&  $CWB::Align;           # cwb\-align
\&  $CWB::AlignEncode;     # cwb\-align\-encode
\&  $CWB::CQPserver;       # cqpserver
\&
\&  # default registry directory and effective registry setting
\&  $CWB::DefaultRegistry;
\&  @dirs = CWB::RegistryDirectory(); # may return multiple directories
\&
\&  # open filehandle for reading or writing
\&  # automagically compresses/decompresses files and dies on error
\&  $fh = CWB::OpenFile("> my_file.gz");
\&  $fh = CWB::OpenFile(">", "my_file.gz"); # as in 3\-argument open() call
\&
\&  # temporary file objects (disk files are automatically removed)
\&  $t1 = new CWB::TempFile;             # picks a unique filename
\&  $t2 = new CWB::TempFile "mytemp";    # extends prefix to unique name
\&  $t3 = new CWB::TempFile "mytemp.gz"; # compressed temporary file
\&  $filename = $t1\->name;        # full pathname of temporary file
\&  $t1\->write(...);              # works like $fh\->print()
\&  $t1\->finish;                  # stop writing file
\&  print $t1\->status, "\en";      # WRITING/FINISHED/READING/DELETED
\&  # main program can read or overwrite file <$filename> now
\&  $line = $t1\->read;            # read one line, like $fh\->getline()
\&  $t1\->rewind;                  # re\-read from beginning of file
\&  $line = $t1\->read;            # (reads first line again)
\&  $t1\->close;                   # stop reading and delete temporary file
\&  # other files will be deleted when objects $t2 and $t3 are destroyed
\&
\&  # execute shell command with automatic error detection
\&  $cmd = "ls \-l";
\&  $errlevel = CWB::Shell::Cmd($cmd);   # dies with error message if not ok
\&  # $errlevel: 0 (ok), 1 (minor problems), ..., 6 (fatal error)
\&  @lines = ();
\&  CWB::Shell::Cmd($cmd, \e@lines);      # capture standard output in array
\&  CWB::Shell::Cmd($cmd, "files.txt");  # ... or in file (for large amounts of data)
\&  $CWB::Shell::Paranoid = 1;    # more paranoid checks (\-1 for less paranoid)
\&
\&  $quoted = CWB::Shell::Quote($string); # quote arbitrary string as shell argument
\&  CWB::Shell::Cmd([$prog, $arg, ...], \e@lines); # auto\-quotes individual arguments
\&
\&  # read / modify / write registry files (must be in canonical format)
\&  $reg = new CWB::RegistryFile; # create new registry file
\&  $reg = new CWB::RegistryFile "/corpora/c1/registry/dickens";  # load file
\&  die "failed" unless defined $reg;    # will fail if not in canonical format
\&
\&  $reg = new CWB::RegistryFile "dickens";       # search in standard registry
\&  $filename = $reg\->filename;                   # retrieve full pathname
\&
\&  # edit standard fields
\&  $name = $reg\->name;           # read NAME field
\&  $reg\->name("Charles Dickens");# modify NAME field
\&  $corpus_id = $reg\->id;        # same for ID, HOME, INFO
\&  $home_dir = $reg\->home;
\&  $info_file = $reg\->info;
\&  $reg\->delete_info;            # INFO line is optional and may be deleted
\&
\&  # edit corpus properties
\&  @properties = $reg\->list_properties;
\&  $value = $reg\->property("language");  # get property value
\&  $reg\->property("language", "en");     # set / add property
\&  $reg\->delete_property("language");
\&
\&  # edit attributes (\*(Aqp\*(Aq=positional, \*(Aqs\*(Aq=structural, \*(Aqa\*(Aq=alignment)
\&  @attr = $reg\->list_attributes;        # list all attributes
\&  @s_attr = $reg\->list_attributes(\*(Aqa\*(Aq); # list alignment attributes
\&  $type = $reg\->attribute("word");      # \*(Aqp\*(Aq/\*(Aqs\*(Aq/\*(Aqa\*(Aq or undef
\&  $reg\->delete_attribute("np");
\&  $reg\->add_attribute("np", \*(Aqs\*(Aq);       # specify type when adding attribute
\&  $dir = $reg\->attribute_path("lemma"); # may be stored in different directory
\&  $reg\->attribute_path("lemma", $dir);  # set attribute path
\&  $reg\->delete_attribute_path;          # default location is HOME directory
\&
\&  # comment lines (preceding field/declaration) and inline comments use keys:
\&  #   ":NAME", ":ID", ... "::$property", ... "$attribute", ...
\&  @lines = $reg\->comments(":HOME");     # comment lines before HOME field
\&  $reg\->set_comments(":INFO", @lines);  # overwrite existing comments
\&  $reg\->add_comments("::language", "", "comment for language property", "");
\&  $reg\->set_comments("::language");     # delete comments before property
\&  $comment = $reg\->line_comment("np");  # inline comment of np attribute
\&  $reg\->line_comment("word", "the required word attribute");  # set comment
\&  $reg\->delete_line_comment("word");    # delete inline comment
\&
\&  # (over)write registry file (requires full pathname)
\&  $reg\->write("/corpora/c1/registry/dickens");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers basic support for using the \s-1IMS\s0 Open Corpus Workbench
(<http://cwb.sourceforge.net/>) from Perl scripts.
Several additional functions are included to perform tasks
that are often needed by corpus-related scripts.
.SH "CWB PATHNAMES"
.IX Header "CWB PATHNAMES"
Package variables give the full pathnames of \fB\s-1CQP\s0\fR and the \fB\s-1CWB\s0 tools\fR, 
so they can be used in shell commands even when they are not
installed in the user's search path. The following variables are available:
.PP
.Vb 10
\&  $CWB::CQP;             # cqp
\&  $CWB::Config;          # cwb\-config
\&  $CWB::Encode;          # cwb\-encode
\&  $CWB::Makeall;         # cwb\-makeall
\&  $CWB::Decode;          # cwb\-decode
\&  $CWB::Lexdecode;       # cwb\-lexdecode
\&  $CWB::DescribeCorpus;  # cwb\-describe\-corpus
\&  $CWB::Huffcode;        # cwb\-huffcode
\&  $CWB::CompressRdx;     # cwb\-compress\-rdx
\&  $CWB::Itoa;            # cwb\-itoa
\&  $CWB::Atoi;            # cwb\-atoi
\&  $CWB::SEncode;         # cwb\-s\-encode
\&  $CWB::SDecode;         # cwb\-s\-decode
\&  $CWB::ScanCorpus;      # cwb\-scan\-corpus
\&  $CWB::Align;           # cwb\-align
\&  $CWB::AlignEncode;     # cwb\-align\-encode
\&  $CWB::CQPserver;       # cqpserver
.Ve
.PP
Other configuration information includes the general installation prefix,
the directory containing \s-1CWB\s0 binaries (which might be used to install additional
software related to the \s-1CWB\s0), and the default registry directory.  \fB\s-1NB:\s0\fR
individual install paths may have overridden the general prefix, so the
package variable \fI\f(CI$CWB::Prefix\fI\fR does not have much practical importance.
Use the \fBcwb-config\fR program to find out the precise installation paths.
.PP
.Vb 4
\&  $CWB::Prefix;          # general installation prefix
\&  $CWB::BinDir;          # directory for CWB binaries (executable programs)
\&  $CWB::DefaultRegistry; # compiled\-in default registry directory
\&  $CWB::CWBVersion;      # release version of the CWB binaries (Perl\-style)
.Ve
.PP
Note that \fI\f(CI$CWB::CWBVersion\fI\fR refers to the release verison of the \s-1CWB\s0 binaries
rather than the Perl module (\fI\f(CI$CWB::VERSION\fI\fR).  All version numbers are encoded
in Perl numeric style (e.g. \f(CW\*(C`3.004_001\*(C'\fR for \s-1CWB\s0 v3.4.1), so specific version
requirements can easily be checked by numeric comparison.
.SH "MISCELLANEOUS FUNCTIONS"
.IX Header "MISCELLANEOUS FUNCTIONS"
.ie n .IP "@dirs = \fBCWB::RegistryDirectory()\fR;" 4
.el .IP "\f(CW@dirs\fR = \fBCWB::RegistryDirectory()\fR;" 4
.IX Item "@dirs = CWB::RegistryDirectory();"
The function \fBCWB::RegistryDirectory\fR can be used to determine the \fIeffective\fR
registry directory (either the compiled-in default registry or a setting made
in the \fI\s-1CORPUS_REGISTRY\s0\fR environment variable). It is possible to specify multiple
registry directories, so \fBCWB::RegistryDirectory\fR returns a list of strings.
.ie n .IP "$fh = CWB::OpenFile($name);" 4
.el .IP "\f(CW$fh\fR = CWB::OpenFile($name);" 4
.IX Item "$fh = CWB::OpenFile($name);"
.PD 0
.ie n .IP "$fh = CWB::OpenFile($mode, $name);" 4
.el .IP "\f(CW$fh\fR = CWB::OpenFile($mode, \f(CW$name\fR);" 4
.IX Item "$fh = CWB::OpenFile($mode, $name);"
.PD
Open file \fI\f(CI$name\fI\fR for reading, writing, or appending. Returns \fBFileHandle\fR
object if successful, otherwise it \fBdie\fRs with an error message. It is thus
never necessary to check whether \fI\f(CI$fh\fI\fR is defined.
.Sp
If \fBCWB::OpenFile\fR is called with two arguments, \fI\f(CI$mode\fI\fR indicates the file
access mode: \f(CW\*(C`<\*(C'\fR for reading, \f(CW\*(C`>\*(C'\fR for writing, \f(CW\*(C`>>\*(C'\fR for
appending, \f(CW\*(C`|\-\*(C'\fR for a write pipe and \f(CW\*(C`\-|\*(C'\fR for a read pipe (see
\&\*(L"open\*(R" in perlfunc for details).  In this form, I/O layers can be appended
to the access mode.  For example, to read a \f(CW\*(C`.gz\*(C'\fR file in \s-1ISO\-8859\-1\s0 encoding,
you can use the command
.Sp
.Vb 1
\&  $fh = CWB::OpenFile("<:encoding(latin1)", $filename);
.Ve
.Sp
In the one-argument form, \fBCWB::OpenFile\fR examines the file name for an
embedded access mode specifier. If \fI\f(CI$name\fI\fR starts with \f(CW\*(C`>\*(C'\fR the file is
opened for writing (an existing file will be overwritten), if it starts
with \f(CW\*(C`>>\*(C'\fR the file is opened for appending. The default is to open
the file for reading, which can optionally be made explicit by a leading \f(CW\*(C`<\*(C'\fR. 
A \f(CW\*(C`|\*(C'\fR at the start or end of \fI\f(CI$name\fI\fR opens a write or read pipe, respectively.
.Sp
Files with extension \f(CW\*(C`.Z\*(C'\fR, \f(CW\*(C`.gz\*(C'\fR, \f(CW\*(C`.bz2\*(C'\fR or \f(CW\*(C`.xz\*(C'\fR are automatically
compressed and decompressed, provided that the necessary programs are installed.
It is also possible to append to \f(CW\*(C`.gz\*(C'\fR and \f(CW\*(C`.bz2\*(C'\fR files.
.SH "TEMPORARY FILES"
.IX Header "TEMPORARY FILES"
Temporary files (implemented by \fBCWB::TempFile\fR objects) are created with 
a unique name and are automatically deleted when the script exits. The
life cycle of a temporary file consists of four stages: \fBcreate\fR, 
\&\fBwrite\fR, \fBread\fR (possibly \fBre-read\fR), \fBdelete\fR. This cycle corresponds
to the following method calls:
.PP
.Vb 7
\&  $tf = new CWB::TempFile;  # create new temporary file in /tmp dir
\&  $tf\->write(...);     # write cycle (buffered output, like print function)
\&  $tf\->finish;         # complete write cycle (flushes buffer)
\&  $line = $tf\->read;   # read cycle (like getline method for FileHandle)
\& [$tf\->rewind;         # optional: start re\-reading temporary file ]
\& [$line = $tf\->read;                                               ]
\&  $tf\->close;          # delete temporary file
.Ve
.PP
Once the temporary file has been read from, it cannot be re-written; a
new \fBCWB::TempFile\fR object has to be created for the next cycle. When
the write stage is completed (but before reading has started, i.e. after
calling the \fBfinish\fR method), the temporary file can be accessed 
and/or overwritten by external programs. Use the \fBname\fR method to
obtain its full pathname. If no direct access to the temporary file is
required, the \fBfinish\fR method is optional. The write cycle will
automatically be completed before the first \fBread\fR method call.
.ie n .IP "$tf = new CWB::TempFile [ $prefix ];" 4
.el .IP "\f(CW$tf\fR = new CWB::TempFile [ \f(CW$prefix\fR ];" 4
.IX Item "$tf = new CWB::TempFile [ $prefix ];"
Creates temporary file in \fI/tmp\fR directory. If the optional \fI\f(CI$prefix\fI\fR
is specified, the filename will begin with \fI\f(CI$prefix\fI\fR and be extended
to a unique name. If \fI\f(CI$prefix\fI\fR contains a \f(CW\*(C`/\*(C'\fR character, it is interpreted
as an absolute or relative path, and the temporary file will not be created
in the \fI/tmp\fR directory. To create a temporary file in the current
working directory, use \fI./MyPrefix\fR.
.Sp
You can add the extension \f(CW\*(C`.Z\*(C'\fR, \f(CW\*(C`.gz\*(C'\fR, or \f(CW\*(C`.bz2\*(C'\fR to \fI\f(CI$prefix\fI\fR in order
to create a compressed temporary file. The actual filename (returned by the
\&\fBname\fR method) will have the same extension in this case.
.Sp
The temporary file is immediately created and opened for writing.
.ie n .IP "$tf\->close;" 4
.el .IP "\f(CW$tf\fR\->close;" 4
.IX Item "$tf->close;"
Closes all open file handles and deletes the temporary file. This will be done
automatically when the \fBCWB::TempFile\fR object is destroyed. Use \fBclose\fR to
free disk space immediately.
.ie n .IP "$filename = $tf\->name;" 4
.el .IP "\f(CW$filename\fR = \f(CW$tf\fR\->name;" 4
.IX Item "$filename = $tf->name;"
Returns the real filename of a temporary file. \fB\s-1NB:\s0\fR direct access to this
file (e.g. by external programs) is \fIonly\fR allowed after calling \fBfinish\fR, 
and before the first \fBread\fR.
.ie n .IP "$status = $tf\->status;" 4
.el .IP "\f(CW$status\fR = \f(CW$tf\fR\->status;" 4
.IX Item "$status = $tf->status;"
Returns the current status of the temporary file, i.e. the stage in its
life cycle.  The return value is one of the strings
\&\f(CW\*(C`WRITING\*(C'\fR (initial state),
\&\f(CW\*(C`FINISHED\*(C'\fR (immediately after \fBfinish\fR, before first read),
\&\f(CW\*(C`READING\*(C'\fR (while reading or after \fBrewind\fR) or
\&\f(CW\*(C`DELETED\*(C'\fR (after \fBclose\fR).
.ie n .IP "$tf\->write(...);" 4
.el .IP "\f(CW$tf\fR\->write(...);" 4
.IX Item "$tf->write(...);"
Write data to the temporary file. All arguments are passed to Perl's 
built-in \fBprint\fR function. Like \fBprint\fR, this method does not automatically
add newlines.
.ie n .IP "$tf\->finish;" 4
.el .IP "\f(CW$tf\fR\->finish;" 4
.IX Item "$tf->finish;"
Stop writing to the temporary file, flush the output buffer, and close 
the associated file handle. Afer \fBfinish\fR has been called, the temporary
file can be accessed directly by the script or external programs, and may
be overwritten by them. In order to automatically delete a file created by
an external program, \fBfinish\fR the temporary file immediately after its
creation and then allow the external tool to overwrite it:
.Sp
.Vb 4
\&  $tf = new CWB::TempFile;
\&  $tf\->finish;  # temporary file has size of 0 bytes now
\&  $filename = $tf\->name;
\&  system "$my_shell_command > $filename";
.Ve
.ie n .IP "$line = $tf\->read;" 4
.el .IP "\f(CW$line\fR = \f(CW$tf\fR\->read;" 4
.IX Item "$line = $tf->read;"
Read one line from temporary file (same as \fBgetline\fR method on \fBFileHandle\fR). 
Automatically invokes \fBfinish\fR if called immediately after write cycle.
.ie n .IP "$tf\->rewind;" 4
.el .IP "\f(CW$tf\fR\->rewind;" 4
.IX Item "$tf->rewind;"
Allows the script to re-read a temporary file. The next \fBread\fR call will return
the first line of the temporary file. Internally this is achieved by closing
and re-opening the associated file handle.
.SH "SHELL COMMANDS"
.IX Header "SHELL COMMANDS"
The \fB\s-1CWB::\s0\fR\fB\fBShell::Cmd()\fB\fR function provides a convenient replacement
for the built-in \fBsystem\fR command. Standard output and error messages
produced by the invoked shell command are captured to avoid screen
clutter, and the former is available to the Perl script (similar to
the backtick operator \f(CW\*(C`\`$shell_cmd\`\*(C'\fR). \fB\s-1CWB::\s0\fR\fB\fBShell::Cmd()\fB\fR also checks
for a variety of error conditions and returns an error level value ranging
from 0 (successful) to 6 (fatal error):
.PP
.Vb 7
\&  Error Level  Description
\&    6          command execution failed (system error)
\&    5          non\-zero exit value or error message on STDERR
\&    4          \-\- reserved for future use \-\-
\&    3          warning message on STDERR
\&    2          any output on STDERR
\&    1          error message on STDOUT
.Ve
.PP
Depending on the value of \fI\f(CI$CWB::Shell::Paranoid\fI\fR, a warning message will
be issued or the function will \fBdie\fR with an error message.
.ie n .IP "$CWB::Shell::Paranoid = 0;" 4
.el .IP "\f(CW$CWB::Shell::Paranoid\fR = 0;" 4
.IX Item "$CWB::Shell::Paranoid = 0;"
With the default setting of 0, \fB\s-1CWB::\s0\fR\fB\fBShell::Cmd()\fB\fR will \fBdie\fR if the
error level is 5 or greater. In the \fBextra paranoid\fR setting (+1), it
will almost always \fBdie\fR (error level 2 or greater). In the \fBless paranoid\fR
setting (\-1) only an error level of 6 (i.e. failure to execute the shell
command) will cause the script to abort.
.ie n .IP "$errlvl = CWB::Shell::Cmd($cmd);" 4
.el .IP "\f(CW$errlvl\fR = CWB::Shell::Cmd($cmd);" 4
.IX Item "$errlvl = CWB::Shell::Cmd($cmd);"
.PD 0
.ie n .IP "$errlvl = CWB::Shell::Cmd($cmd, $filename);" 4
.el .IP "\f(CW$errlvl\fR = CWB::Shell::Cmd($cmd, \f(CW$filename\fR);" 4
.IX Item "$errlvl = CWB::Shell::Cmd($cmd, $filename);"
.ie n .IP "$errlvl = CWB::Shell::Cmd($cmd, \e@lines);" 4
.el .IP "\f(CW$errlvl\fR = CWB::Shell::Cmd($cmd, \e@lines);" 4
.IX Item "$errlvl = CWB::Shell::Cmd($cmd, @lines);"
.PD
The first form executes \fI\f(CI$cmd\fI\fR as a shell command (through the built-in
\&\fBsystem\fR function) and returns an error level value. With the default
setting of \fI\f(CI$CWB::Shell::Paranoid\fI\fR, serious errors are usually detected and
cause the script to \fBdie\fR, so it is not necessary to check \fI\f(CI$errlvl\fI\fR.
.Sp
The second form stores the standard output of the shell command in
file \fI\f(CI$filename\fI\fR. It can then be processed with external programs or
read in by the Perl script. \fB\s-1NB:\s0\fR Compressed files are not supported!
It is recommended to use an uncompressed temporary file (\fBCWB::TempFile\fR object).
.Sp
The third form requires an array reference as its second argument. It splits
the standard output of the shell command into \fBchomp\fRed lines and stores them
in \fI\f(CI@lines\fI\fR. If there is a large amount of standard ouput, it is more efficient
to use the second form.
.ie n .IP "$errlvl = CWB::Shell::Cmd([$prog, $arg, ...], ...);" 4
.el .IP "\f(CW$errlvl\fR = CWB::Shell::Cmd([$prog, \f(CW$arg\fR, ...], ...);" 4
.IX Item "$errlvl = CWB::Shell::Cmd([$prog, $arg, ...], ...);"
In each form of \fBCWB::Shell::Cmd\fR, the string \fI\f(CI$cmd\fI\fR can be replaced by an array reference
containing the program to be called and its individual arguments.  The arguments will
automatically be quoted in a way that is safe at least in \fBbash\fR and \fBtcsh\fR shells.  Note that
simple option flags with values must be passed as two separate arguments in this case,
e.g. \f(CW\*(C`[$CWB::DescribeCorpus, "\-r", $registry, "DICKENS"]\*(C'\fR.
.Sp
If you want to execute a multi-command pipeline or use other shell metacharacters
in your command, you have to use the \fBCWB::Shell::Quote\fR function to quote literal arguments yourself.
.ie n .IP "$safe = CWB::Shell::Quote($argument);" 4
.el .IP "\f(CW$safe\fR = CWB::Shell::Quote($argument);" 4
.IX Item "$safe = CWB::Shell::Quote($argument);"
Safely quote \fI\f(CI$argument\fI\fR as a command-line argument in \fBbash\fR and \fBtcsh\fR shells.
Simple strings that consist only of \s-1ASCII\s0 letters and digits, \f(CW\*(C`_\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`/\*(C'\fR
are passed through without quotes.  The \fBCWB::Shell::Quote\fR function is vectorised, 
so multiple argument strings can be passed in a single call.
.SH "REGISTRY FILE EDITING"
.IX Header "REGISTRY FILE EDITING"
Registry files in \fBcanonical format\fR can be loaded into \fBCWB::RegistryFile\fR objects,
edited using the various access methods detailed below, and written back to disk. It
is also possible to create a registry entry from scratch and save it to a disk file.
.PP
Canonical registry files consist of a \fBheader\fR and a \fBbody\fR. The
\&\fBheader\fR begins with a \s-1NAME, ID, PATH,\s0 and optional \s-1INFO\s0 field
.PP
.Vb 4
\&  NAME "long descriptive name"
\&  ID   my\-corpus
\&  PATH /path/to/data/directory
\&  INFO /path/to/info/file.txt
.Ve
.PP
followed by optional \fBcorpus property\fR definitions
.PP
.Vb 2
\&  ##:: property1 = "value1"
\&  ##:: property2 = "value2"
.Ve
.PP
The \fBbody\fR declares \fBpositional\fR, \fBstructural\fR, and \fBalignment\fR attributes in
arbitrary order, using the following keywords
.PP
.Vb 3
\&  ATTRIBUTE  word     # positional attribute
\&  STRUCTURE  np       # structural attribute
\&  ALIGNED    corpus2  # alignment attribute (CORPUS2 is target corpus)
.Ve
.PP
Each attribute declaration may be followed by an alternative directory path on
the same line, if the attribute data is not stored in the \s-1HOME\s0 directory of the
corpus:
.PP
.Vb 1
\&  ATTRIBUTE  lemma  /path/to/other/data/directory
.Ve
.PP
The header fields, corpus properties, and attribute declarations are jointly
referred to as \fBcontent lines\fR. Each content line may be preceded by an arbitrary
number of \fBcomment lines\fR (starting with a \f(CW\*(C`#\*(C'\fR character) and \fBblank lines\fR.
Trailing comments and blank lines (i.e. after the last content line in a registry
file) are allowed but will be ignored by \fBCWB::RegistryFile\fR. Besides, each 
content line may include an \fBin-line comment\fR which extends from the first \f(CW\*(C`#\*(C'\fR
character to the end of the line (see examples above). Note that lines starting
with the special symbol \f(CW\*(C`##::\*(C'\fR are interpreted as corpus property definitions
rather than comments.
.ie n .IP "$reg = new CWB::RegistryFile;" 4
.el .IP "\f(CW$reg\fR = new CWB::RegistryFile;" 4
.IX Item "$reg = new CWB::RegistryFile;"
.PD 0
.ie n .IP "$reg = new CWB::RegistryFile $filename;" 4
.el .IP "\f(CW$reg\fR = new CWB::RegistryFile \f(CW$filename\fR;" 4
.IX Item "$reg = new CWB::RegistryFile $filename;"
.PD
The first form of the \fBCWB::RegistryFile\fR constructor creates a new, 
empty registry entry. The mandatory fields have to be filled in by the
Perl script before the \fI\f(CI$reg\fI\fR object can be saved to disk. It is also highly
advisable to declare at least the \f(CW\*(C`word\*(C'\fR attribute. :\-)
.Sp
The second form attempts to read and parse the registry file \fI\f(CI$filename\fI\fR. If
successful, a \fBCWB::RegistryFile\fR object storing all relevant information is
returned.  If \fI\f(CI$filename\fI\fR does not contain the character \f(CW\*(C`/\*(C'\fR and cannot be
found in the current directory, the constructor will automatically search the
standard registry directories for it.  The full pathname of the registry file
can later be determined with the \fBfilename\fR method.
.Sp
If the load operation failed (i.e. the file does not exist or is not in the
canonical registry file format), an error message is printed and an undefined
value returned (so this module can be used e.g. to write a robust graphical
registry editor). Always check the return value of the constructor before
proceeding.
.ie n .IP "$filename = $reg\->filename;" 4
.el .IP "\f(CW$filename\fR = \f(CW$reg\fR\->filename;" 4
.IX Item "$filename = $reg->filename;"
Get the full pathname of the registry file represented by \fI\f(CI$reg\fI\fR.  This value
is undefined if \fI\f(CI$reg\fI\fR was created as a new (empty) registry entry.
.ie n .IP "$name = $reg\->name;" 4
.el .IP "\f(CW$name\fR = \f(CW$reg\fR\->name;" 4
.IX Item "$name = $reg->name;"
.PD 0
.ie n .IP "$id   = $reg\->id;" 4
.el .IP "\f(CW$id\fR   = \f(CW$reg\fR\->id;" 4
.IX Item "$id = $reg->id;"
.ie n .IP "$home = $reg\->home;" 4
.el .IP "\f(CW$home\fR = \f(CW$reg\fR\->home;" 4
.IX Item "$home = $reg->home;"
.ie n .IP "$info = $reg\->info;" 4
.el .IP "\f(CW$info\fR = \f(CW$reg\fR\->info;" 4
.IX Item "$info = $reg->info;"
.PD
Get the values of the \s-1NAME, ID, HOME,\s0 and \s-1INFO\s0 fields from the registry file
header. Since the \s-1INFO\s0 field is optional, the \fB\fBinfo()\fB\fR method may return an
undefined value.
.ie n .IP "$reg\->name($value);" 4
.el .IP "\f(CW$reg\fR\->name($value);" 4
.IX Item "$reg->name($value);"
.PD 0
.ie n .IP "$reg\->id($value);" 4
.el .IP "\f(CW$reg\fR\->id($value);" 4
.IX Item "$reg->id($value);"
.ie n .IP "$reg\->home($value);" 4
.el .IP "\f(CW$reg\fR\->home($value);" 4
.IX Item "$reg->home($value);"
.ie n .IP "$reg\->info($value);" 4
.el .IP "\f(CW$reg\fR\->info($value);" 4
.IX Item "$reg->info($value);"
.ie n .IP "$reg\->delete_info;" 4
.el .IP "\f(CW$reg\fR\->delete_info;" 4
.IX Item "$reg->delete_info;"
.PD
Modify the \s-1NAME, ID, HOME,\s0 and \s-1INFO\s0 fields. The \s-1INFO\s0 field is optional and
may be deleted.
.ie n .IP "@properties = $reg\->list_properties;" 4
.el .IP "\f(CW@properties\fR = \f(CW$reg\fR\->list_properties;" 4
.IX Item "@properties = $reg->list_properties;"
.PD 0
.ie n .IP "$value = $reg\->property($property);" 4
.el .IP "\f(CW$value\fR = \f(CW$reg\fR\->property($property);" 4
.IX Item "$value = $reg->property($property);"
.PD
Corpus properties are key / value pairs. The \fB\fBlist_properties()\fB\fR method
returns a list of the keys, i.e. the names of defined properties. Use the
\&\fB\fBproperty()\fB\fR method to obtain the value of a single property \fI\f(CI$property\fI\fR.
.ie n .IP "$reg\->property($property, $value);" 4
.el .IP "\f(CW$reg\fR\->property($property, \f(CW$value\fR);" 4
.IX Item "$reg->property($property, $value);"
.PD 0
.ie n .IP "$reg\->delete_property($property);" 4
.el .IP "\f(CW$reg\fR\->delete_property($property);" 4
.IX Item "$reg->delete_property($property);"
.PD
You can also use the \fB\fBproperty()\fB\fR method to set the value of a property
by passing a second argument. This will add a new corpus property if
\&\fI\f(CI$property\fI\fR isn't already defined. Use \fB\fBdelete_property()\fB\fR to remove
a corpus property.
.ie n .IP "@attr = $reg\->list_attributes;" 4
.el .IP "\f(CW@attr\fR = \f(CW$reg\fR\->list_attributes;" 4
.IX Item "@attr = $reg->list_attributes;"
.PD 0
.ie n .IP "@attr_of_type = $reg\->list_attributes($type);" 4
.el .IP "\f(CW@attr_of_type\fR = \f(CW$reg\fR\->list_attributes($type);" 4
.IX Item "@attr_of_type = $reg->list_attributes($type);"
.ie n .IP "$type = $reg\->attribute($att_name);" 4
.el .IP "\f(CW$type\fR = \f(CW$reg\fR\->attribute($att_name);" 4
.IX Item "$type = $reg->attribute($att_name);"
.PD
\&\fB\fBlist_attributes()\fB\fR returns the names of all declared attributes. The
\&\fB\fBattribute()\fB\fR method returns the type of the specified attribute, or an
undefined value if the attribute is not declared. \fI\f(CI$type\fI\fR is one of
\&\f(CW\*(Aqp\*(Aq\fR (\fBpositional\fR), \f(CW\*(Aqs\*(Aq\fR (\fBstructural\fR), or \f(CW\*(Aqa\*(Aq\fR (\fBalignment\fR). 
Passing one of these type codes to \fB\fBlist_attributes()\fB\fR will return
attributes of the selected type only.
.ie n .IP "$reg\->add_attribute($att_name, $type);" 4
.el .IP "\f(CW$reg\fR\->add_attribute($att_name, \f(CW$type\fR);" 4
.IX Item "$reg->add_attribute($att_name, $type);"
.PD 0
.ie n .IP "$reg\->delete_attribute($att_name);" 4
.el .IP "\f(CW$reg\fR\->delete_attribute($att_name);" 4
.IX Item "$reg->delete_attribute($att_name);"
.PD
\&\fB\fBadd_attribute()\fB\fR adds an attribute of type \fI\f(CI$type\fI\fR (\fBp\fR, \fBs\fR, or
\&\fBa\fR, see above). The duplicate declaration of an attribute with the
same type is silently ignored. Re-declaration with a different type is
a fatal error. Use \fB\fBdelete_attribute()\fB\fR to remove an attribute of the
specified name, regardless of its type.
.ie n .IP "$directory = $reg\->attribute_path($att_name);" 4
.el .IP "\f(CW$directory\fR = \f(CW$reg\fR\->attribute_path($att_name);" 4
.IX Item "$directory = $reg->attribute_path($att_name);"
.PD 0
.ie n .IP "$reg\->attribute_path($att_name, $directory);" 4
.el .IP "\f(CW$reg\fR\->attribute_path($att_name, \f(CW$directory\fR);" 4
.IX Item "$reg->attribute_path($att_name, $directory);"
.ie n .IP "$reg\->delete_attribute_path;" 4
.el .IP "\f(CW$reg\fR\->delete_attribute_path;" 4
.IX Item "$reg->delete_attribute_path;"
.PD
Use the \fB\fBattribute_path()\fB\fR method to get and set the alternative
data path of attribute \fI\f(CI$att_name\fI\fR. If no alternative path is
specified in the registry entry, an undefined value is returned.
When an alternative path is deleted with \fB\fBdelete_attribute_path()\fB\fR, 
the attribute will look for its data files in the \s-1HOME\s0 directory
of the corpus.
.ie n .IP "@lines = $reg\->comments($key);" 4
.el .IP "\f(CW@lines\fR = \f(CW$reg\fR\->comments($key);" 4
.IX Item "@lines = $reg->comments($key);"
.PD 0
.ie n .IP "$reg\->add_comments($key, @lines);" 4
.el .IP "\f(CW$reg\fR\->add_comments($key, \f(CW@lines\fR);" 4
.IX Item "$reg->add_comments($key, @lines);"
.ie n .IP "$reg\->set_comments($key, @lines);" 4
.el .IP "\f(CW$reg\fR\->set_comments($key, \f(CW@lines\fR);" 4
.IX Item "$reg->set_comments($key, @lines);"
.ie n .IP "$reg\->set_comments($key);" 4
.el .IP "\f(CW$reg\fR\->set_comments($key);" 4
.IX Item "$reg->set_comments($key);"
.PD
Comment lines in a registry file are associated with the first content
line following the comments. They are available through the
\&\fB\fBcomments()\fB\fR method as a list of \fBchomp\fRed lines with the initial
\&\f(CW\*(C`#\*(C'\fR character removed. Since comment lines may precede any kind of
content line, a special key \fI\f(CI$key\fI\fR is used to identify the desired
content line.
.Sp
.Vb 3
\&  $key = ":NAME";       header field (same for ":ID", ":HOME", ":INFO")
\&  $key = "::$property"; definition of corpus property $property
\&  $key = $att_name;     declaration of attribute $att_name
.Ve
.Sp
Use \fB\fBadd_comments()\fB\fR to add \fI\f(CI@lines\fI\fR to the existing comments for 
\&\fI\f(CI$key\fI\fR. The new comments are always inserted immediately before the
content line. The \fB\fBset_comments()\fB\fR method overwrites existing comments
with \fI\f(CI@lines\fI\fR. The second form deletes all comments for \fI\f(CI$key\fI\fR
(replacing them with zero new comment lines). Note that \f(CW""\fR represents
a blank line and \f(CW"#..."\fR a comment line beginning with two sharps
\&\f(CW\*(C`##\*(C'\fR.
.ie n .IP "$comment = $reg\->line_comment($key);" 4
.el .IP "\f(CW$comment\fR = \f(CW$reg\fR\->line_comment($key);" 4
.IX Item "$comment = $reg->line_comment($key);"
.PD 0
.ie n .IP "$reg\->line_comment($key, $comment);" 4
.el .IP "\f(CW$reg\fR\->line_comment($key, \f(CW$comment\fR);" 4
.IX Item "$reg->line_comment($key, $comment);"
.ie n .IP "$reg\->delete_line_comment($key);" 4
.el .IP "\f(CW$reg\fR\->delete_line_comment($key);" 4
.IX Item "$reg->delete_line_comment($key);"
.PD
Inline comments use the same \fI\f(CI$key\fI\fR identifiers as comment lines.
Just as with the \s-1INFO\s0 field, the \fB\fBline_comment()\fB\fR method allows you
to get and set inline comments, and \fB\fBdelete_line_comment()\fB\fR removes
an inline comment.
.ie n .IP "$reg\->write($filename);" 4
.el .IP "\f(CW$reg\fR\->write($filename);" 4
.IX Item "$reg->write($filename);"
Write registry file to disk in canonical format. \fI\f(CI$filename\fI\fR has to be a full
absolute or relative path.  For safety reasons, the \fB\fBwrite()\fB\fR method does
\&\fInot\fR automatically save a file in the default registry directory.  Make sure
that the filename is all lowercase and identical to the corpus \s-1ID,\s0 or the \s-1CWB\s0
tools and \s-1CQP\s0 will not be able to read the registry file.
.Sp
If \fI\f(CI$reg\fI\fR was initialised from a registry file, \fI\f(CI$filename\fI\fR can be omitted.
In this case, the original file will automatically be overwritten.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1999\-2022 Stephanie Evert [https://purl.org/stephanie.evert]
.PP
This software is provided \s-1AS IS\s0 and the author makes no warranty as to
its use and performance. You may use the software, redistribute and
modify it under the same terms as Perl itself.
