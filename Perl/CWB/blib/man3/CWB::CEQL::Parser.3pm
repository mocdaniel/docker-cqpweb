.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CWB::CEQL::Parser 3"
.TH CWB::CEQL::Parser 3 "2022-05-07" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CWB::CEQL::Parser \- Deterministic Perl parser for simplified query languages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  ##### DPP grammar in separate module #####
\&  package MyGrammar;
\&  use base \*(AqCWB::CEQL::Parser\*(Aq;
\&
\&  sub my_rule {
\&    my ($self, $input) = @_;
\&    ## body of grammar rule "my_rule" goes here, transforming $input => $output
\&    return $output;
\&  }
\&
\&  sub default {
\&    ## default rule is applied to parser input string
\&    my ($self, $input) = @_;
\&    return $self\->Call("my_rule", $input);        # recursively call other grammar rules
\&  }
\&
\&  1;
\&
\&  ##### main program #####
\&  use MyGrammar;
\&  our $grammar = new MyGrammar;
\&
\&  $result = $grammar\->Parse($string);             # applies \*(Aqdefault\*(Aq rule
\&  $result = $grammar\->Parse($string, "my_rule");  # parse as given constituent
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBCWB::CEQL::Parser\fR implements a \fBheuristic\fR\-driven, \fBdeterministic\fR,
\&\fBtop-down\fR parser for extended context-free grammars written in \fBPerl\fR,
called a \fBD\fReterministic \fBP\fRerl \fBP\fRarser (\fB\s-1DPP\s0\fR).  This parsing algorithm
was designed specifically for automatic translation of simplified, user-friendly
query and scripting languages (such as the \fBC\fRommon \fBE\fRlementary \fBQ\fRuery
\&\fBL\fRanguage provided by \fB\s-1CWB::CEQL\s0\fR) into low-level code (e.g. \fB\s-1CQP\s0\fR syntax).
.PP
The \s-1DPP\s0 architecture was motivated by the observation that simplified queries
are often very similar in structure to the corresponding low-level queries,
and that many authors use cascaded regular expression substitutions to
transform one into the other.  While such cascades are very easy to write in
Perl and perform efficiently, there are two important limitations: it would
often be useful (i) to validate and transform recursive structures, and (ii)
to restrict a particular transformation to a certain scope.  Because of these
limitations, incorrect user input \*(-- and sometimes even correct input \*(-- leads
to malformed low-level queries.  Without an intimate knowledge of the
implementation, it is often impossible to guess the true location of the
problem from the cryptic error messages generated by the backend processor.
Moreover, simplified query languages based on regular expression substitution
typically have rather limited expressiveness and flexibility (because the
substitutions are applied unconditionally, so symbols cannot have different
meanings in different contexts).
.PP
\&\fBCWB::CEQL::Parser\fR aims to overcome these limitations by combining
regexp-based matching and substitution with a simple top-down parser for
context-free grammars, as well as a shift-reduce-style parser for nested
bracketing.  Parsing complexity is limited by enforcing a \fBfully
deterministic\fR parsing algorithm: a \fB\s-1DPP\s0 rule\fR (= constituent type,
corresponding to the \s-1LHS\s0 of a traditional \s-1CFG\s0 rule) may have multiple
expansions, but the Perl code implementing the rule has to employ heuristics
to choose a single expansion for a given input.  If the selected expansion
does not match the input string, the entire parsing process fails.  Again,
this decision was motivated by the observation that, in the case of simplified
query languages, it is often very easy to make such deterministic decisions
with a regular expression and/or a few lines of Perl code.
.PP
Each \fB\s-1DPP\s0 rule\fR is implemented as a \fBPerl subroutine\fR (or, more precisely,
\&\fBmethod\fR).  It is called by the parser with an input string that is expected
to be a constituent of the respective type, and returns its analysis of this
constituent.  In the typical application of \s-1DPP\s0 grammars, the return value is
a string representing (part of) a low-level query expression, but grammar
authors may also decide to return arbitrary data structures.  In the \fBrule
body\fR, other grammar rules can be applied to the full input string, a
substring, or an arbitrarily transformed substring using the \fBCall\fR method.
It is also possible to invoke a shift-reduce-type parser with the \fBApply\fR
method.  Both methods return an analysis of the given substring, which can
then be integrated with the analyses of other substrings and the parsing
performed by the rule body itself.
.PP
The section on \*(L"\s-1WRITING GRAMMARS\*(R"\s0 below explains in detail how to write new
\&\s-1DPP\s0 grammars from scratch; \*(L"\s-1GRAMMAR RULES\*(R"\s0 presents some typical design
patterns for grammar rules and lists the methods available to grammar writers;
\&\*(L"\s-1EXTENDING GRAMMARS\*(R"\s0 shows how to extend and modify existing grammars (such
as the standard \s-1CEQL\s0 implementation provided by the \fB\s-1CWB::CEQL\s0\fR module);
\&\*(L"USER-VISIBLE \s-1METHODS\*(R"\s0 documents methods aimed at grammar users; \*(L"\s-1METHODS
USED BY GRAMMAR AUTHORS\*(R"\s0 documents methods for grammar writers; and
\&\*(L"\s-1INTERNAL METHODS\*(R"\s0 contains short descriptions of methods used internally
by the parser.
.SH "WRITING GRAMMARS"
.IX Header "WRITING GRAMMARS"
Technically, a \fB\s-1DPP\s0 grammar\fR is a subclass of \fBCWB::CEQL::Parser\fR, which
defines \fB\s-1DPP\s0 rules\fR in the form of Perl \fBmethods\fR, and inherits parsing and
housekeeping methods from the base class.  Instantiating such a grammar class
yields an independent parser object.
.PP
By convention, the names of \fBrule methods\fR are written in lowercase with
underscores (e.g., \f(CW\*(C`word_and_pos\*(C'\fR), \fBmethods for users and grammar writers\fR
are written in mixed case (e.g., \f(CW\*(C`Parse\*(C'\fR or \f(CW\*(C`SetParam\*(C'\fR), and \fBinternal
methods\fR are written in mixed case starting with a lowercase letter (e.g.,
\&\fBformatHtmlString\fR).  If you need to define helper subroutines in your grammar
class, their names should begin with an underscore (e.g., \f(CW\*(C`_escape_regexp\*(C'\fR)
to avoid confusion with grammar rules.  The \f(CW\*(C`default\*(C'\fR rule has to be
implemented by all grammars and will be applied to an input string if no
constituent type is specified.  The basic skeleton of a \s-1DPP\s0 grammar therefore
looks like this:
.PP
.Vb 2
\&  package MyGrammar;
\&  use base \*(AqCWB::CEQL::Parser\*(Aq;
\&
\&  sub some_rule {
\&    ## body of grammar rule "some_rule" goes here
\&  }
\&
\&  sub default {
\&    ## default rule will be called if parser is applied to string
\&  }
\&
\&  1; # usually, a grammar is implemented as a separate module file
.Ve
.PP
The user instantiates a parser for this grammar as an object of type
\&\fBMyGrammar\fR, then calls the \fBParse\fR method to analyse an input string
(optionally specifying the expected constituent type if it is different from
\&\f(CW\*(C`default\*(C'\fR).  \fBParse\fR returns an analysis of the input string in the form
chosen by the grammar author.  In most cases, including the standard
\&\fB\s-1CWB::CEQL\s0\fR grammar, this will simply be a string containing a low-level
query expression.  Additional information can be returned by using objects of
class \fBCWB::CEQL::String\fR, which behave like strings in most contexts
(through operator overloading) but can also be assigned a user-specified type
(see the CWB::CEQL::String manpage for details).  Alternatively, an
arbitrary data structure or object can be returned instead of a string.  We
will assume in the following that \s-1DPP\s0 rules always return plain strings.
.PP
.Vb 2
\&  use MyGrammar;
\&  our $grammar = new MyGrammar;
\&
\&  $result = $grammar\->Parse($string);              # applies \*(Aqdefault\*(Aq rule
\&  $result = $grammar\->Parse($string, "some_rule"); # parse as given constituent type
.Ve
.PP
If parsing fails, the \fBParse\fR method returns \fBundef\fR.  A full description of
the error and where it occurred can then be obtained with the \fBErrorMessage\fR
and \fBHtmlErrorMessage\fR methods:
.PP
.Vb 2
\&  @lines_of_text = $grammar\->ErrorMessage;
\&  $html_code = $grammar\->HtmlErrorMessage;
.Ve
.PP
The latter takes care of encoding special characters as \s-1HTML\s0 entities where
necessary and has been included to simplify the integration of \s-1DPP\s0 grammars
into Web interfaces.
.PP
Internally, \fBParse\fR will invoke appropriate grammar rules.  In the first
example above, the \fBdefault\fR method would be called with argument \fI\f(CI$string\fI\fR;
in the second example, \fBsome_rule\fR would be called.  A typical \s-1DPP\s0 rule
performs the following operations:
.IP "1." 4
examine the input string to decide whether it appears to be a suitable
constituent, and to determine its internal structure
.IP "2." 4
if the test in Step 1 fails, \fBdie\fR with a meaningful error message;
the \fBParse\fR method will catch this exception and report it to the user
together with a stack trace of where the error occured
.IP "3." 4
make a deterministic choice of further processing steps, i.e. the rule commits
to a specific analysis of the input string and cannot go back on this decision
later on
.IP "4." 4
apply other grammar rules to substrings of the input using the \fBCall\fR method,
or split the input into a sequence of tokens passed to the \fBApply\fR method
(which invokes a shift-reduce-type parser); note that the rule has to make sure
that these substrings are constituents of the specified type
.IP "5." 4
collect the parsing results for subconstituents returned in Step 4, optionally
add further parts of the input string, and apply necessary transformations;
the resulting string is returned as the rule's transformation of the input
(alternatively, an arbitrary data structure can be returned as an analysis of
the input string)
.PP
Note that \s-1DPP\s0 rules always return an analysis or transformation of their
input; they are \fInot allowed\fR to return \fBundef\fR in order to show that the
input string failed to parse.  This is a consequence of the deterministic
nature of the \s-1DPP\s0 approach: the caller guarantees that the input is a
constituent of the specified type \*(-- anything else is an error condition and
causes the rule to \fBdie\fR.  The two main adavantages of the \s-1DPP\s0 approach are
that (i) the parser does not have to perform any backtracking and (ii) grammar
rules do not need to check the return values of subrules invoked with \fBCall\fR
or \fBApply\fR.
.PP
Sometimes, it may be unavoidable to try different analyses of an input string
in sequence.  In such exceptional cases, grammar writers can use the \fBTry\fR
method to perform a simple type of backtracking.  \fBTry\fR works exactly like
\&\fBCall\fR, but will catch any exception raised due to a parse failure and return
\&\fBundef\fR in this case.  Grammar writers are strongly advised to avoid
backtracking whenever possible, though: the deterministic nature of \s-1DPP\s0 is
essential for efficient parsing, and repeated backtracking will greatly
increase its computational complexity.
.PP
\&\s-1DPP\s0 grammars can be \fBcustomised\fR in two ways.  One possibility is to
\&\fBoverride existing rules\fR by subclassing the grammar, as described in the
section on \*(L"\s-1EXTENDING GRAMMARS\*(R"\s0.  This offers an extremely flexible way of
changing grammar behaviour, but requires a detailed knowledge of the
\&\fBCWB::CEQL::Parser\fR module and the internal design of the grammar.
.PP
A much easier customisation strategy is for grammar writers to define named
\&\fBparameters\fR, which can then be set by end users in order to control certain
features of the grammar.  Typical applications of parameters include the
following:
.IP "\(bu" 4
customisation of corpus attribute names (e.g., a parameter \f(CW\*(C`pos_attribute\*(C'\fR
might specify the appropriate positional attribute for part-of-speech tags,
such as \f(CW\*(C`pos\*(C'\fR or \f(CW\*(C`tag\*(C'\fR)
.IP "\(bu" 4
activating or deactivating certain grammar rules (e.g., a parameter
\&\f(CW\*(C`has_lemma\*(C'\fR might indicate whether a corpus includes lemmatisation
information or not; if it is \s-1FALSE,\s0 then input strings including lemma
constraints will raise parse errors in the respective grammar rules)
.IP "\(bu" 4
definition of lookup tables for simplified part-of-speech tags (which have to
be adapted to the tagset used by a particular corpus)
.PP
Named parameters have to be defined in the constructor (i.e. the \fBnew\fR
method) of a grammar by calling the \fBNewParam\fR method, which also sets a
default value for the new parameter.  They can then be modified or read out at
any time using the \fBSetParam\fR and \fBGetParam\fR methods.  It is an error to
set or read the value of a parameter that hasn't previously been defined.
.PP
A typical skeletion of a \s-1DPP\s0 grammar with parameters looks as follows:
.PP
.Vb 2
\&  package MyGrammar;
\&  use base \*(AqCWB::CEQL::Parser\*(Aq;
\&
\&  sub new {
\&    my $class = shift;
\&    my $self = new CWB::CEQL::Parser;
\&    $self\->NewParam("pos_attribute", "pos");
\&    return bless($self, $class);
\&  }
\&
\&  sub pos_tag {
\&    my ($self, $input) = @_;
\&    my $pos_att = $self\->GetParam("pos_attribute");
\&    die "\*(Aq$input\*(Aq does not appear to be a valid POS tag\en"
\&      unless $input =~ /^[A\-Z0\-9]+$/;
\&    return "$pos_att = \*(Aq$input\*(Aq"; # CQP constraint for POS tag
\&  }
\&
\&  # ... other grammar rules, including "default" ...
\&
\&  1;
.Ve
.PP
If your grammar does not define its own parameters, it is not necessary to
provide an explicit implementation of the \fBnew\fR method (unless some other
initialisation has to be performed).
.PP
A user can now apply \fBMyGrammar\fR to a corpus that stores \s-1POS\s0 tags in
a p\-attribute named \f(CW\*(C`tag\*(C'\fR:
.PP
.Vb 1
\&  use MyGrammar;
\&
\&  our $grammar = new MyGrammar;
\&  $grammar\->SetParam("pos_attribute", "tag");
\&
\&  $cqp_query = $grammar\->Parse($simple_query);
.Ve
.PP
The following section presents some typical design patterns for \s-1DPP\s0 rules and
explains the use of \fBCall\fR, \fBApply\fR and \fBTry\fR.  Complete function
references are found in the sections \*(L"USER-VISIBLE \s-1METHODS\*(R"\s0 and \*(L"\s-1METHODS
USED BY GRAMMAR AUTHORS\*(R"\s0.  If you want to see an example of a complete \s-1DPP\s0
grammar, it is a good idea to take a look at the implementation of the
standard \s-1CEQL\s0 grammar in the \fB\s-1CWB::CEQL\s0\fR module.  Knowledge of this grammar
implementation is essential if you want to build your own custom \s-1CEQL\s0
extensions.
.SH "GRAMMAR RULES"
.IX Header "GRAMMAR RULES"
.SS "Stand-alone rules"
.IX Subsection "Stand-alone rules"
The simplest \s-1DPP\s0 rules are stand-alone rules that transform their input string
directly without invoking any subrules.  These rules typically make use of regular
expression substitutions and correspond to one part of the substitution cascade
in a traditional implementation of simple query languages.  In contrast to such
cascades, \s-1DPP\s0 rules apply only to relevant parts of the input string and cannot
accidentally modify other parts of the simple query.  The example below transforms
a search term with shell-style wildcards (\f(CW\*(C`?\*(C'\fR and \f(CW\*(C`*\*(C'\fR) into a regular expression.
Note how the input string is first checked to make sure it does not contain any
other metacharacters that might have a special meaning in the generated regular
expression, and \fBdie\fRs with an informative error message otherwise.
.PP
.Vb 9
\&  sub wildcard_expression {
\&    my ($self, $input) = @_;
\&    die "the wildcard expression \*(Aq\*(Aq$input\*(Aq\*(Aq contains invalid characters\en"
\&      unless $input =~ /^[A\-Za\-z0\-9?*\-]+$/;
\&    my $regexp = $input;
\&    $regexp =~ s/\e?/./g;
\&    $regexp =~ s/\e*/.*/g;
\&    return $regexp;
\&  }
.Ve
.PP
Alternatively, the rule could escape all regular expression metacharacters in
the input string so they are matched literally by the regular expression.
This version of the grammar might use an internal subroutine for translating
strings with wildcards safely into regular expressions:
.PP
.Vb 4
\&  sub wildcard_expression {
\&    my ($self, $input) = @_;
\&    return _wildcard_to_regexp($input);
\&  }
\&
\&  # note leading underscore for internal subroutine (this is not a method!)
\&  sub _wildcard_to_regexp {
\&    my $s = quotemeta(shift);
\&    $s =~ s/\e\e[?]/./g;  # wildcards will also have been escaped with a backslash
\&    $s =~ s/\e\e([*+])/.$1/g;  # works for wildcards * and +
\&    return $s;
\&  }
.Ve
.SS "Handling parse errors"
.IX Subsection "Handling parse errors"
\&\s-1DPP\s0 rules should always carry out strict checks to ensure that their input is
a well-formed constituent of the required type, and \fBdie\fR with a clear and
informative error message otherwise.  This helps users to locate and correct
syntax errors in their input.  If errors are caught too late, i.e. in deeply
nested subrules, it may be difficult to recognise the true cause of the
problem.
.PP
The error message passed to \fBdie\fR should be limited to a single line of text
if possible.  Always append a newline character (\f(CW\*(C`\en\*(C'\fR) in order to suppress
the automatic Perl stack trace, which provides no useful information for
grammar users and is likely to be confusing.  \fBCWB::CEQL::Parser\fR will add
its own stack trace of subrule invocations so that users can pinpoint the
precise location of the syntax error.  In order to make this stack trace
readable and informative, \s-1DPP\s0 rules should always be given descriptive names: use
\&\f(CW\*(C`wildcard_expression\*(C'\fR or \f(CW\*(C`part_of_speech\*(C'\fR rather than \f(CW\*(C`rule1723a\*(C'\fR.
.PP
The \fBHtmlErrorMessage\fR method will automatically convert \s-1HTML\s0 metacharacters
and non-ASCII characters to entities, so it is safe to include the returned
\&\s-1HTML\s0 code directly in a Web page.  Error messages may use basic wiki-style
formatting: \f(CW\*(Aq\*(Aq...\*(Aq\*(Aq\fR for typewriter font, \f(CW\*(C`//...//\*(C'\fR for italics and
\&\f(CW\*(C`**...**\*(C'\fR for bold font.  Note that such markup is non-recursive and nested
formatting will be ignored.  User input should always be enclosed in
\&\f(CW\*(Aq\*(Aq...\*(Aq\*(Aq\fR in error messages so that \f(CW\*(C`//\*(C'\fR and \f(CW\*(C`**\*(C'\fR sequences in the input
are not mistaken as formatting instructions.
.SS "Calling subrules"
.IX Subsection "Calling subrules"
Most \s-1DPP\s0 rules divide the input string into one or more subconstituents,
similar to the rules of a standard context-free grammar.  The main difference
is that a \s-1DPP\s0 rule has to settle on the specific positions and categories
of the subconstituents, rather than just listing possible category sequences.
Many \s-1DPP\s0 rules will also remove syntactic operators and delimiters, so that
only complex subconstituents are passed to other rules for parsing with the
\&\fBCall\fR method.
.PP
The following example allows users to search for a word form using either a
wildcard pattern or a regular expression enclosed in \f(CW\*(C`/.../\*(C'\fR.  The return
value is a \s-1CQP\s0 query.  As an additional optimisation, wildcard patterns that
do not contain any wildcards are matched literally (which is faster than a
regular expression and avoids possible conflicts with regexp metacharacters).
.PP
.Vb 10
\&  sub wordform_pattern {
\&    my ($self, $input) = @_;
\&    die "the wordform pattern \*(Aq\*(Aq$input\*(Aq\*(Aq must not contain whitespace or double quotes\en"
\&      if $input =~ /\es|\e"/;
\&    if ($input =~ /^\e/(.+)\e/$/) {
\&      my $regexp = $1; # regular expression query: simply wrap in double quotes
\&      return "\e"$regexp\e"";
\&    }
\&    else {
\&      if ($input =~ /[?*+]/) {
\&        my $regexp = $self\->Call("wildcard_expression", $input); # call subrule
\&        return "\e"$regexp\e"";
\&      }
\&      else {
\&        return "\e"$input\e"\e%l";
\&      }
\&    }
\&  }
.Ve
.PP
It would probably be a good idea to signal an error if the wordform pattern
starts or ends with a slash (\f(CW\*(C`/\*(C'\fR) but is not enclosed in \f(CW\*(C`/.../\*(C'\fR as a
regular expression query.  This is likely to be a typing mistake and the user
will be confused if the input is silently interpreted as a wildcard
expression.
.SS "Parsing sequences"
.IX Subsection "Parsing sequences"
If the input string consists of a variable number of subconstituents of the
same type, the \fBApply\fR method provides a convenient alternative to repeated
subrule calls.  It parses all specified subconstituents, collects the parse
results and returns them as a list.  The following example processes queries
that consist of a sequence of wordform patterns separated by blanks (each pattern
is either a wildcard expression or regular expression, according to the \s-1DPP\s0
rules defined above), and returns an equivalent \s-1CQP\s0 query.
.PP
.Vb 6
\&  sub wordform_sequence {
\&    my ($self, $input) = @_;
\&    my @items = split " ", $input;
\&    my @cqp_patterns = $self\->Apply("wordform_pattern", @items);
\&    return "@cqp_patterns";
\&  }
.Ve
.PP
Recall that the list returned by \fBApply\fR does not have to be validated: if
any error occurs, the respective subrule will \fBdie\fR and abort the complete
parse.
.SS "The shift-reduce parser for nested bracketing"
.IX Subsection "The shift-reduce parser for nested bracketing"
The \fBApply\fR method is more than a convenient shorthand for parsing lists of
constituents.  Its main purpose is to parse nested bracketing structures,
which are very common in the syntax of formal languages (examples include
arithmetical formulae, regular expressions and most computer programming
languages).  When parsing the constituents of a list with nested bracketing,
two special methods, \fBBeginGroup\fR and \fBEndGroup\fR, are called to mark opening
and closing delimiters.  Proper nesting will then automatically be verified by
the \s-1DPP\s0 parser.  If the syntax allows different types of groups to be mixed,
optional names can be passed to the \fBBeginGroup\fR and \fBEndGroup\fR calls in
order to ensure that the different group types match properly.
.PP
The output generated by the items of a bracketing group is collected
separately and returned when \fBEndGroup\fR is called.  From this list, the rule
processing the closing delimiter has to construct a single expression for the
entire group.  Note that the return value of the \s-1DPP\s0 rule calling
\&\fBBeginGroup\fR becomes part of the bracketing group output.  If this is not
desired, the rule must return an empty string (\f(CW""\fR).  Rules can also check
whether they are in a nested group with the help of the \fBNestingLevel\fR method
(which returns 0 at the top level).
.PP
The example below extends our simple query language with regexp-style
parenthesised groups, quantifiers (\f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR) and alternatives (\f(CW\*(C`|\*(C'\fR).
In order to simplify the implementation, metacharacters must be separated from
wordform patterns and from other metacharacters by blanks; and quantifiers
must be attached directly to a closing parenthesis (otherwise, the question
mark in \f(CW\*(C`) ?\*(C'\fR would be ambiguous between a quantifier and a wildcard pattern
matching a single character).  Note that the \f(CW\*(C`simple_query\*(C'\fR rule is
practically identical to \f(CW\*(C`wordform_sequence\*(C'\fR above, but has been renamed to
reflect its new semantics.
.PP
.Vb 6
\&  sub simple_query {
\&    my ($self, $input) = @_;
\&    my @items = split " ", $input;
\&    my @cqp_tokens = $self\->Apply("simple_query_item", @items);
\&    return "@cqp_tokens";
\&  }
\&
\&  # need to define single rule to parse all items of a list with nested bracketing
\&  sub simple_query_item {
\&    my ($self, $item) = @_;
\&    # opening delimiter: (
\&    if ($item eq "(") {
\&      $self\->BeginGroup();
\&      return "";  # opening delimiter should not become part of group output
\&    }
\&    # alternatives separator: | (only within nested group)
\&    elsif ($item eq "|") {
\&      die "a group of alternatives (|) must be enclosed in parentheses\en"
\&        unless $self\->NestingLevel > 0; # | metacharacter is not allowed at top level
\&      return "|";
\&    }
\&    # closing delimiter: ) with optional quantifier
\&    elsif ($item =~ /^\e)([?*+]?)$/) {
\&      my $quantifier = $1;
\&      my @cqp_tokens = $self\->EndGroup();
\&      die "empty groups \*(Aq( )\*(Aq are not allowed\en"
\&        unless @cqp_tokens > 0;
\&      return "(@cqp_tokens)$quantifier";
\&    }
\&    # all other tokens should be wordform patterns
\&    else {
\&      return $self\->Call("wordform_pattern", $item);
\&    }
\&  }
.Ve
.PP
For a complete grammar implementation, don't forget to specify the default rule!
.PP
.Vb 4
\&  sub default {
\&    my ($self, $input) = @_;
\&    $self\->Call("simple_query", $input);
\&  }
.Ve
.SS "Structural transformations with the shift-reduce parser"
.IX Subsection "Structural transformations with the shift-reduce parser"
The \fBApply\fR mechanism does not implement a full-fledged shift-reduce parser.
It is well suited for nested bracketing, where structures have explicit start
and end markers, but it cannot automatically handle structural transformations
that are needed e.g. to parse infix operators.  The running example in this
subsection will be a grammar for simple arithmetic expressions, consisting of
numbers, \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`\-\*(C'\fR operators, and parentheses for grouping.  For instance,
the expression \f(CW\*(C`42 \- (9 \- 6)\*(C'\fR should be transformed into nested function calls
\&\f(CW\*(C`sub(42, sub(9, 6))\*(C'\fR.
.PP
One strategy for parsing such expressions is simply to collect all elements
within a group, and then perform necessary transformations on the list
returned by the \fBEndGroup\fR method when a closing delimiter is encountered.
This approach is facilitated by the \fBCWB::CEQL::String\fR module, which allows
strings returned by grammar rules to be annotated with type information
(technically, \fBCWB::CEQL::String\fR objects are complex data structures which
can be interpolated like ordinary strings).  In our example, strings are
either operators (type \f(CW\*(C`Op\*(C'\fR) or terms (numbers or parenthesised
subexpressions, type \f(CW\*(C`Term\*(C'\fR).  A flat sequence of terms and operators is
translated into nested function calls by the internal function
\&\f(CW\*(C`_shift_reduce\*(C'\fR, which repeatedly collapses a sequence \f(CW\*(C`Term Op Term\*(C'\fR into a
single \f(CW\*(C`Term\*(C'\fR.  Note that \f(CW\*(C`_shift_reduce\*(C'\fR has to be called in two places in
the grammar: (1) at the end of each bracketing group and (2) for the top-level
sequence returned by the \fBApply\fR method.
.PP
.Vb 3
\&  package Arithmetic;
\&  use base \*(AqCWB::CEQL::Parser\*(Aq;
\&  use CWB::CEQL::String;
\&
\&  sub default {
\&    my ($self, $input) = @_;
\&    return $self\->Call("arithmetic_expression", $input);
\&  }
\&
\&  sub arithmetic_expression {
\&    my ($self, $input) = @_;
\&    $input =~ s/([()+\-])/ $1 /g;            # insert whitespace around metacharacters
\&    $input =~ s/^\es+//; $input =~ s/\es+$//; # strip leading/trailing whitespace
\&    my @items = split " ", $input;          # split on whitespace into items (numbers, operators, parentheses)
\&    my @terms_ops = $self\->Apply("arithmetic_item", @items); # returns list of Term\*(Aqs and Op\*(Aqs
\&    return $self\->_shift_reduce(@terms_ops);
\&  }
\&
\&  sub arithmetic_item {
\&    my ($self, $item) = @_;
\&    if ($item eq "+")    { return new CWB::CEQL::String "add", "Op" }
\&    elsif ($item eq "\-") { return new CWB::CEQL::String "sub", "Op" }
\&    elsif ($item eq "(") { $self\->BeginGroup("subexpression"); return "" }
\&    elsif ($item eq ")") {
\&      my @terms_ops = $self\->EndGroup("subexpression");
\&      return $self\->_shift_reduce(@terms_ops);
\&    }
\&    elsif ($item =~ /^[0\-9]+$/) { return new CWB::CEQL::String $item, "Term" }
\&    else { die "invalid element \*(Aq\*(Aq $item \*(Aq\*(Aq in arithmetic expression\en" }
\&  }
\&
\&  sub _shift_reduce {
\&    my ($self, @terms_ops) = @_;
\&    while (@terms_ops >= 3) {
\&      # reduce first three items (which must be Term Op Term) to single Term
\&      my @types = map {$_\->type} @terms_ops;
\&      die "syntax error in arithmetic expression\en"
\&        unless "@types" =~ /^Term Op Term/; # wrong sequence of terms and operators
\&      my $t1 = shift @terms_ops;
\&      my $op = shift @terms_ops;
\&      my $t2 = shift @terms_ops;
\&      my $new_term = new CWB::CEQL::String "$op($t1, $t2)", "Term";
\&      unshift @terms_ops, $new_term;
\&    }
\&    die "syntax error in arithmetic expression\en"
\&      unless @terms_ops == 1;     # wrong number of items
\&    return shift @terms_ops;
\&  }
.Ve
.PP
The obvious drawback of this approach is the difficulty of signaling the
precise location of a syntax error to the user (in the example grammar above,
the parser will simply print \f(CW\*(C`syntax error\*(C'\fR if there is any problem in a
sequence of terms and operators).  By the time the error is detected, all
items in the active group have already been pre-processed and subexpressions
have been collapsed.  Printing the current list of terms and operators would
only add to the user's confusion.
.PP
In order to signal errors immediately where they occur, each item should be
validated before it is added to the result list (e.g. an operator may not be
pushed as first item on a result list), and the reduce operation (\f(CW\*(C`Term Op
Term => Term\*(C'\fR) should be applied as soon as possible.  The rule
\&\f(CW\*(C`arithmetic_item\*(C'\fR needs direct access to the currently active result list for
this purpose: (1) to check how many items have already been pushed when
validating a new item, and (2) to reduce a sequence \f(CW\*(C`Term Op Term\*(C'\fR to a single
\&\f(CW\*(C`Term\*(C'\fR in the result list.
.PP
A pointer to the currently active result list is obtained with the internal
\&\fBcurrentGroup\fR method, allowing a grammar rule to manipulate the result list.
The \fBproximity queries\fR in the \fB\s-1CWB::CEQL\s0\fR grammar illustrate this advanced
form of shift-reduce parsing.
.SS "Backtracking with \fBTry()\fP"
.IX Subsection "Backtracking with Try()"
\&\fB** \s-1TODO\s0 **\fR
.SH "EXTENDING GRAMMARS"
.IX Header "EXTENDING GRAMMARS"
\&\fB** \s-1TODO\s0 **\fR
.SH "USER-VISIBLE METHODS"
.IX Header "USER-VISIBLE METHODS"
Methods that are called by the \*(L"end users\*(R" of a grammar.
.IP "\fI\f(CI$grammar\fI\fR = \fBnew\fR MyGrammar;" 4
.IX Item "$grammar = new MyGrammar;"
Create parser object \fI\f(CI$grammar\fI\fR for the specified grammar (which must be a
class derived from \fBCWB::CEQL::Parser\fR).  Note that the parser itself is not
reentrant, but multiple parsers for the same grammar can be run in parallel.
The return value \fI\f(CI$grammar\fI\fR is an object of class \fBMyGrammar\fR.
.IP "\fI\f(CI$result\fI\fR = \fI\f(CI$grammar\fI\fR\->\fBParse\fR(\fI\f(CI$string\fI\fR [, \fI\f(CI$rule\fI\fR]);" 4
.IX Item "$result = $grammar->Parse($string [, $rule]);"
Parse input string \fI\f(CI$string\fI\fR as a constituent of type \fI\f(CI$rule\fI\fR (if
unspecified, the \f(CW\*(C`default\*(C'\fR rule will be used).  The return value \fI\f(CI$result\fI\fR
is typically a string containing the transformed query, but may also be an
arbitrary data structure or object (such as a parse tree for \fI\f(CI$input\fI\fR).
Consult the relevant grammar documentation for details.  If parsing fails,
\&\fBundef\fR is returned.
.IP "\fI\f(CI@lines_of_text\fI\fR = \fI\f(CI$grammar\fI\fR\->\fBErrorMessage\fR;" 4
.IX Item "@lines_of_text = $grammar->ErrorMessage;"
If the last parse failed, returns a detailed error message and backtrace of
the callstack as a list of text lines (without newlines).  Otherwise, returns
empty list.
.IP "\fI\f(CI$html_code\fI\fR = \fI\f(CI$grammar\fI\fR\->\fBHtmlErrorMessage\fR;" 4
.IX Item "$html_code = $grammar->HtmlErrorMessage;"
If the last parse failed, returns HTML-formatted error message and backtrace
of the callstack.  The string \fI\f(CI$html_code\fI\fR is valid \s-1HTML\s0 and can directly be
included in a generated Web page.  In particular, unsafe and non-ASCII
characters have been encoded as \s-1HTML\s0 entities.  Simple, non-recursive
wiki-style markup in an error message is interpreted in the following way:
.Sp
.Vb 3
\&  **<text>**    <text> is shown in bold font (<b> ... </b>)
\&  //<text>//    <text> is displayed in italics (<i> ... </i>)
\&  \*(Aq\*(Aq<text>\*(Aq\*(Aq    <text> is shown in typewriter font (<code> ... </code>)
.Ve
.Sp
Lines starting with \f(CW\*(C` \- \*(C'\fR (note the two blanks) are converted into list items.
.IP "\fI\f(CI$grammar\fI\fR\->\fBSetParam\fR(\fI\f(CI$name\fI\fR, \fI\f(CI$value\fI\fR);" 4
.IX Item "$grammar->SetParam($name, $value);"
.PD 0
.IP "\fI\f(CI$value\fI\fR = \fI\f(CI$grammar\fI\fR\->\fBGetParam\fR(\fI\f(CI$name\fI\fR);" 4
.IX Item "$value = $grammar->GetParam($name);"
.PD
Set the value of parameter \fI\f(CI$name\fI\fR (\fBSetParam\fR), or read its current value
(\fBGetParam\fR).  The parameter \fI\f(CI$name\fI\fR must have been defined by the grammar
class (which \fI\f(CI$grammar\fI\fR is an instance of) and should be described in the
grammar's documentation.
.SH "METHODS USED BY GRAMMAR AUTHORS"
.IX Header "METHODS USED BY GRAMMAR AUTHORS"
Methods for grammar authors.  Since these methods are intended for use in the
rules of a \s-1DPP\s0 grammar, they are typically applied to the object \fI\f(CI$self\fI\fR.
.IP "\fI\f(CI$self\fI\fR\->\fBNewParam\fR(\fI\f(CI$name\fI\fR, \fI\f(CI$default_value\fI\fR);" 4
.IX Item "$self->NewParam($name, $default_value);"
Define new parameter \fI\f(CI$name\fI\fR with default value \fI\f(CI$default_value\fI\fR.  This
method is normally called in the constructor (method \fBnew\fR) of a
parameterized grammar.  If it is used in a rule body, the new parameter
will be created in the working copy of the parameter set and will only be
available during the current parse.
.IP "\fI\f(CI$result\fI\fR = \fI\f(CI$self\fI\fR\->\fBCall\fR(\fI\f(CI$rule\fI\fR, \fI\f(CI$input\fI\fR);" 4
.IX Item "$result = $self->Call($rule, $input);"
Apply rule \fI\f(CI$rule\fI\fR to input string \fI\f(CI$input\fI\fR.  The return value \fI\f(CI$result\fI\fR
depends on the grammar rule, but is usually a string containing a translated
version of \fI\f(CI$input\fI\fR.  Grammar rules may also annotate this string with
\&\fBattributes\fR or by \fBbless\fRing it into a custom class, or return a complex
data structure such as a parse tree for \fI\f(CI$input\fI\fR.  The caller has to be aware
what kind of value \fI\f(CI$rule\fI\fR returns.
.Sp
Note that \fBCall\fR never returns \fBundef\fR.  In case of an error, the entire
parse is aborted.
.IP "\fI\f(CI$result\fI\fR = \fI\f(CI$self\fI\fR\->\fBTry\fR(\fI\f(CI$rule\fI\fR, \fI\f(CI$input\fI\fR);" 4
.IX Item "$result = $self->Try($rule, $input);"
Tentatively apply rule \fI\f(CI$rule\fI\fR to the input string.  If \fI\f(CI$input\fI\fR is parsed
successfully, \fBTry\fR returns the translated version \fI\f(CI$result\fI\fR (or an
arbitrary data structure such as a parse tree for \fI\f(CI$input\fI\fR) just as \fBCall\fR
would.  If parsing fails, \fBTry\fR does not abort but simply returns \fBundef\fR,
ignoring any error messages generated during the attempt.  In addition, the
call stack is restored and all parameters are reset to their previous values,
so that parsing can continue as if nothing had happened (note, however, that
this is based on flat backup copies, so complex data structures may have been
altered destructively).
.IP "\fI\f(CI@results\fI\fR = \fI\f(CI$self\fI\fR\->\fBApply\fR(\fI\f(CI$rule\fI\fR, \fI\f(CI@items\fI\fR);" 4
.IX Item "@results = $self->Apply($rule, @items);"
Apply rule \fI\f(CI$rule\fI\fR to each input string in the list \fI\f(CI@items\fI\fR.  The return
values are collected and returned as a list \fI\f(CI@results\fI\fR, which has to be
further processed by the caller.  Note that empty strings (\f(CW""\fR) are
automatically removed from the list of return values.
.IP "\fI\f(CI$self\fI\fR\->\fBBeginGroup\fR([\fI\f(CI$name\fI\fR]);" 4
.IX Item "$self->BeginGroup([$name]);"
Marks the start of a nested group, when an opening delimiter is encountered.
\&\fBBeginGroup\fR may only be called while the shift-reduce parser is active
during an \fBApply\fR operation.  The optional parameter \fI\f(CI$name\fI\fR can be used to
ensure proper nesting of different types of groups; the default group name is
\&\f(CW\*(C`*\*(C'\fR.  After calling \fBBeginGroup\fR, a \s-1DPP\s0 rule will often return \f(CW""\fR since
the opening determiner has a purely syntactic function and is not generate
output directly.
.IP "\fI\f(CI@group_results\fI\fR = \fI\f(CI$self\fI\fR\->\fBEndGroup\fR([\fI\f(CI$name\fI\fR]);" 4
.IX Item "@group_results = $self->EndGroup([$name]);"
Marks the end of a nested group, when a closing delimiter is encountered.  The
optional parameter \fI\f(CI$name\fI\fR (or the default name \f(CW\*(C`*\*(C'\fR) must be identical to
the group name of the matching opening delimiter.  \fBEndGroup\fR returns a list
containing the result values collected from this nested group.
.IP "\fI\f(CI$n\fI\fR = \fI\f(CI$self\fI\fR\->\fBNestingLevel\fR;" 4
.IX Item "$n = $self->NestingLevel;"
Returns the nesting depth \fI\f(CI$n\fI\fR of the current group during an \fBApply\fR
operation.  A nesting depth of 0 corresponds to the top level.
\&\fBNestingLevel\fR may only be called while the shift-reduce parser is active and
will \fBdie\fR otherwise.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
Internal methods of \fBCWB::CEQL::Parser\fR.
.IP "\fI\f(CI$array_ref\fI\fR = \fI\f(CI$self\fI\fR\->\fBcurrentGroup\fR;" 4
.IX Item "$array_ref = $self->currentGroup;"
Returns a pointer to the currently active result list during an \fBApply\fR
operation (either the top-level result list, or the local result list in a
nested group).  This pointer can be used to access previously collected
return values (before \fBEndGroup\fR is called), and to manipulate the result
list (e.g. to perform advanced shift-reduce parsing).
.Sp
It is an error to call this method while the shift-reduce parser is not
active.
.IP "\fI\f(CI$html_code\fI\fR = \fI\f(CI$grammar\fI\fR\->\fBformatHtmlText\fR(\fI\f(CI@lines_of_text\fI\fR);" 4
.IX Item "$html_code = $grammar->formatHtmlText(@lines_of_text);"
Format one or more text lines with simple wiki-style markup as \s-1HTML.\s0  The
string \fI\f(CI$html_code\fI\fR is valid \s-1HTML\s0 and can directly be included in a generated
Web page.  In particular, unsafe and non-ASCII characters are automatically
encoded as \s-1HTML\s0 entities.  The following typographic markup is supported:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`**<text>**\*(C'\fR \- <text> is displayed in bold face (\f(CW\*(C`<b> ... </b>\*(C'\fR)
.IP "\(bu" 4
\&\f(CW\*(C`//<text>//\*(C'\fR \- <text> is displayed in italics (\f(CW\*(C`<i> ... </i>\*(C'\fR)
.IP "\(bu" 4
\&\f(CW\*(Aq\*(Aq<text>\*(Aq\*(Aq\fR \- <text> is shown in typewriter font (\f(CW\*(C`<code> ... </code>\*(C'\fR)
.IP "\(bu" 4
lines starting with \f(CW\*(C` \- \*(C'\fR (note the two blanks before and after the
hyphen) are converted into list items
.IP "\(bu" 4
all other lines are formatted as separate paragraphs (\f(CW\*(C`<p> ... </p>\*(C'\fR)
.RE
.RS 4
.Sp
The wiki markup is non-recursive, i.e. no substitutions will be applied to
the text wrapped in \f(CW\*(Aq\*(Aq...\*(Aq\*(Aq\fR etc.  This behaviour is intentional, so that
e.g. \fB**\fR in a query expression will not be mistaken for a bold face marker,
(as long as the query is displayed in typewriter font, i.e. as \f(CW\*(C`\*(Aq\*(Aq<query\*(C'\fR''>).
.RE
.IP "\fI\f(CI$html\fI\fR = \fI\f(CI$grammar\fI\fR\->\fBencodeEntities\fR(\fI\f(CI$string\fI\fR);" 4
.IX Item "$html = $grammar->encodeEntities($string);"
Replacement for \fBencode_entities\fR function from \fBHTML::Entities\fR, to avoid
dependency on this package (which is not part of the standard library).
Transforms unsafe characters \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`&\*(C'\fR and \f(CW\*(C`"\*(C'\fR into \s-1HTML\s0
entities, normalises whitespace and removes other control characters.
.Sp
If \fI\f(CI$string\fI\fR is a Unicode string, all non-ASCII characters are replaced
by numerical entities (otherwise, an unknown 8\-bit character set is assumed,
so no substitutions can be made).
.SS "Internal structure of CWB::CEQL::Parser objects"
.IX Subsection "Internal structure of CWB::CEQL::Parser objects"
A \s-1DPP\s0 parser object (i.e. an object that belongs to \fBCWB::CEQL::Parser\fR or
one of its subclasses) is a data structure (hashref) with the following
variables:
.IP "\s-1PARAM_DEFAULTS\s0" 4
.IX Item "PARAM_DEFAULTS"
A hashref containing the global values of grammar parameters, i.e. values set
by the main program for this parser object or the default values defined by
the grammar class.
.IP "\s-1PARAM\s0" 4
.IX Item "PARAM"
Working copy of the grammar parameters, which is used while parsing and may be
modified by grammar rules without affecting the global values.  During a
parse, the \fBNewParam\fR, \fBSetParam\fR and \fBGetParam\fR methods operate on this
working copy.
.Sp
The \f(CW\*(C`PARAM\*(C'\fR variable is re-initialised before each parse with a flat copy of
the \f(CW\*(C`PARAM_DEFAULTS\*(C'\fR hashref.  Therefore, care has to be taken when modifying
complex parameter values within grammar rules, as the changes will affect the
global values in \f(CW\*(C`PARAM_DEFAULTS\*(C'\fR.  If complex values need to be changed
internally, the grammar rule should always update the parameter with
\&\fBSetParam\fR and a deep copy of the previous parameter value.
.IP "\s-1INPUT\s0" 4
.IX Item "INPUT"
The current input string passed to the \fBParse\fR method.  This variable is
mostly used to indicate whether the parser is currently active or not (e.g. in
order to avoid nested \fBParse\fR calls).
.IP "\s-1ERROR\s0" 4
.IX Item "ERROR"
Error message generated by the last parse, or \fBundef\fR if the parse was
successful.  This error message is returned by \fBErrorMessage\fR and
\&\fBHtmlErrorMessage\fR together with a backtrace of the parser's call stack.
.IP "\s-1CALLSTACK\s0" 4
.IX Item "CALLSTACK"
The \f(CW\*(C`CALLSTACK\*(C'\fR variable is an arrayref with information about the nested
calls of grammar rules and their input strings.  Each array element
corresponds to a nested rule invocation and is a hashref with the following
fields:
.RS 4
.IP "\s-1RULE\s0" 4
.IX Item "RULE"
Name of the grammar rule (i.e. Perl \fBmethod\fR) invoked.  When the shift-reduce
parser is called with \fBApply\fR, a special rule named \f(CW\*(C`APPLY\*(C'\fR is pushed on the
stack.
.IP "\s-1INPUT\s0" 4
.IX Item "INPUT"
Input string for the grammar rule (which should be a constituent of the
respective type).
.ie n .IP "\s-1APPLY_ITEMS\s0 (optional, ""\s-1APPLY""\s0 rule only)" 4
.el .IP "\s-1APPLY_ITEMS\s0 (optional, ``\s-1APPLY''\s0 rule only)" 4
.IX Item "APPLY_ITEMS (optional, APPLY rule only)"
List (arrayref) of items passed to \fBApply\fR for processing by the shift-reduce
parser.  This field is only present in the call stack entry for the special
\&\f(CW\*(C`APPLY\*(C'\fR rule.  Items are shifted from this list to \f(CW\*(C`APPLY_DONE\*(C'\fR as they are
processed by the shift-reduce parser.
.ie n .IP "\s-1APPLY_DONE\s0 (optional, ""\s-1APPLY""\s0 rule only)" 4
.el .IP "\s-1APPLY_DONE\s0 (optional, ``\s-1APPLY''\s0 rule only)" 4
.IX Item "APPLY_DONE (optional, APPLY rule only)"
Items from the list passed to \fBApply\fR that have already been handled by the
shift-reduce parser.  The main purpose of \f(CW\*(C`APPLY_ITEMS\*(C'\fR and \f(CW\*(C`APPLY_DONE\*(C'\fR is
to narrow down the location of parse errors in a nested bracketing structure.
.RE
.RS 4
.RE
.IP "\s-1GROUPS\s0" 4
.IX Item "GROUPS"
List (arrayref) of arrayrefs collecting parse results for nested bracketing
groups.  The first element of this list corresponds to the currently active
bracketing group.  The \f(CW\*(C`GROUPS\*(C'\fR variable is only defined while the
shift-reduce parser is active.
.IP "\s-1GROUPSTACK\s0" 4
.IX Item "GROUPSTACK"
Stack (arrayref) of nested bracketing groups.  Each stack element corresponds
to one level of nesting and is a string giving the type of the respective
group.  If no type has been specified by the user, the default value \f(CW\*(C`*\*(C'\fR is
used.  The length of this array can be used to determine the current nesting
depth.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2005\-2022 Stephanie Evert [https://purl.org/stephanie.evert]
.PP
This software is provided \s-1AS IS\s0 and the author makes no warranty as to
its use and performance. You may use the software, redistribute and
modify it under the same terms as Perl itself.
